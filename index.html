<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>T20 World Cup 2026 - Villa Hakatha Predictions</title>

    <!-- Favicon - Cricket Ball Icon -->
    <link rel="icon" type="image/svg+xml" href="favicon.svg">
    <link rel="apple-touch-icon" href="favicon.svg">
    <link rel="manifest" href="manifest.json">
    <meta name="theme-color" content="#0047AB">

    <!-- Google Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Bebas+Neue&family=Rajdhani:wght@400;500;600;700&family=Russo+One&display=swap" rel="stylesheet">

    <style>
        :root {
            --primary-blue: #0047AB;
            --secondary-blue: #1E5BA8;
            --accent-blue: #2E7DBF;
            --light-blue: #E3F2FD;
            --white: #FFFFFF;
            --text-dark: #1a1a1a;
            --text-gray: #666666;
            --success-green: #28a745;
            --error-red: #dc3545;
            --warning-orange: #ff9800;
            --border-gray: #e0e0e0;
            --shadow-sm: 0 2px 4px rgba(0,71,171,0.1);
            --shadow-md: 0 4px 12px rgba(0,71,171,0.15);
            --shadow-lg: 0 8px 24px rgba(0,71,171,0.2);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Rajdhani', sans-serif;
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            color: var(--text-dark);
            min-height: 100vh;
        }

        .header {
            background: linear-gradient(135deg, var(--primary-blue) 0%, var(--secondary-blue) 100%);
            color: var(--white);
            padding: 1rem 2rem;
            box-shadow: var(--shadow-lg);
            position: sticky;
            top: 0;
            z-index: 1000;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 1rem;
        }

        .header-left {
            display: flex;
            align-items: center;
            gap: 1rem;
            flex: 1;
        }

        .header-logo {
            width: 55px;
            height: 55px;
            border-radius: 10px;
            object-fit: contain;
            filter: drop-shadow(0 2px 6px rgba(0,0,0,0.3));
            flex-shrink: 0;
        }

        .header-text h1 {
            font-family: 'Bebas Neue', cursive;
            font-size: 2rem;
            letter-spacing: 2px;
            text-transform: uppercase;
            line-height: 1.1;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .header-text .subtitle {
            font-size: 0.95rem;
            font-weight: 500;
            opacity: 0.95;
        }

        .user-info {
            display: flex;
            align-items: center;
            gap: 1rem;
            flex-shrink: 0;
        }

        .user-info span {
            font-weight: 600;
            font-size: 1.1rem;
        }

        .logout-btn {
            background: rgba(255,255,255,0.2);
            border: 2px solid var(--white);
            color: var(--white);
            padding: 0.5rem 1.2rem;
            border-radius: 25px;
            cursor: pointer;
            font-family: 'Rajdhani', sans-serif;
            font-weight: 600;
            font-size: 1rem;
            transition: all 0.3s ease;
        }

        .logout-btn:hover {
            background: var(--white);
            color: var(--primary-blue);
            transform: translateY(-2px);
        }

        .admin-badge {
            background: #ffd700;
            color: #000;
            padding: 0.3rem 0.8rem;
            border-radius: 15px;
            font-size: 0.85rem;
            font-weight: 700;
            text-transform: uppercase;
        }

        /* Login Page - Split Screen Gen-Z Design */
        .login-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            min-height: 100vh;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            overflow-y: auto;
            overflow-x: hidden;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
        }

        /* LEFT SIDE - Login Form */
        .login-left {
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 3rem;
            background: linear-gradient(135deg, rgba(255, 165, 0, 0.05) 0%, rgba(30, 30, 100, 0.8) 100%);
            position: relative;
            overflow-y: auto;
            overflow-x: hidden;
            min-height: 100vh;
        }

        .login-left::before {
            content: '';
            position: absolute;
            width: 500px;
            height: 500px;
            background: radial-gradient(circle, rgba(255, 165, 0, 0.15) 0%, transparent 70%);
            top: -250px;
            left: -250px;
            animation: float 6s ease-in-out infinite;
        }

        .login-left::after {
            content: '';
            position: absolute;
            width: 300px;
            height: 300px;
            background: radial-gradient(circle, rgba(0, 71, 171, 0.2) 0%, transparent 70%);
            bottom: -150px;
            right: -150px;
            animation: float 8s ease-in-out infinite reverse;
        }

        @keyframes float {
            0%, 100% { transform: translate(0, 0) scale(1); }
            50% { transform: translate(30px, 30px) scale(1.1); }
        }

        .login-form-wrapper {
            width: 100%;
            max-width: 420px;
            position: relative;
            z-index: 10;
        }

        .login-container h2 {
            font-family: 'Bebas Neue', cursive;
            font-size: 3.5rem;
            background: linear-gradient(135deg, #ffa500 0%, #ff6b35 50%, #f7931e 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 0.5rem;
            letter-spacing: 3px;
            text-shadow: 0 0 30px rgba(255, 165, 0, 0.5);
            animation: glow 2s ease-in-out infinite;
        }

        @keyframes glow {
            0%, 100% { filter: drop-shadow(0 0 10px rgba(255, 165, 0, 0.4)); }
            50% { filter: drop-shadow(0 0 20px rgba(255, 165, 0, 0.8)); }
        }

        .login-container p {
            color: rgba(255, 255, 255, 0.7);
            margin-bottom: 2.5rem;
            font-size: 1.2rem;
            font-weight: 500;
        }

        .login-form {
            display: flex;
            flex-direction: column;
            gap: 1.8rem;
        }

        /* RIGHT SIDE - Glassmorphism Logo */
        .login-right {
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 3rem;
            background: linear-gradient(135deg, rgba(0, 71, 171, 0.1) 0%, rgba(30, 30, 100, 0.3) 100%);
            position: relative;
            overflow: hidden;
        }

        .login-right::before {
            content: '';
            position: absolute;
            width: 600px;
            height: 600px;
            background: radial-gradient(circle, rgba(30, 91, 168, 0.3) 0%, transparent 70%);
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            animation: pulse 4s ease-in-out infinite;
        }

        @keyframes pulse {
            0%, 100% { transform: translate(-50%, -50%) scale(1); opacity: 0.5; }
            50% { transform: translate(-50%, -50%) scale(1.2); opacity: 0.8; }
        }

        .logo-glass-card {
            background: rgba(255, 255, 255, 0.08);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border: 2px solid rgba(255, 255, 255, 0.15);
            border-radius: 40px;
            padding: 4rem;
            box-shadow:
                0 8px 32px 0 rgba(31, 38, 135, 0.37),
                inset 0 0 60px rgba(255, 165, 0, 0.1);
            position: relative;
            z-index: 10;
            transition: all 0.4s ease;
        }

        .logo-glass-card:hover {
            transform: translateY(-10px) scale(1.02);
            box-shadow:
                0 15px 50px 0 rgba(255, 165, 0, 0.4),
                inset 0 0 80px rgba(255, 165, 0, 0.2);
            border-color: rgba(255, 165, 0, 0.4);
        }

        .logo-glass-card img {
            width: 100%;
            max-width: 400px;
            height: auto;
            filter: drop-shadow(0 0 30px rgba(255, 165, 0, 0.6));
            transition: all 0.4s ease;
        }

        .logo-glass-card:hover img {
            filter: drop-shadow(0 0 50px rgba(255, 165, 0, 0.9));
            transform: scale(1.05);
        }

        /* Trophy icon style (replaces image) */
        .logo-glass-card .trophy-icon {
            font-size: 12rem;
            text-align: center;
            line-height: 1;
            animation: float 3s ease-in-out infinite;
        }

        @keyframes float {
            0%, 100% { transform: translateY(0px); }
            50% { transform: translateY(-20px); }
        }

        .logo-glass-card .trophy-text {
            text-align: center;
            margin-top: 2rem;
            color: rgba(255, 255, 255, 0.9);
            font-family: 'Bebas Neue', cursive;
            font-size: 2.5rem;
            letter-spacing: 3px;
            text-shadow: 0 0 20px rgba(255, 165, 0, 0.6);
        }

        .input-group {
            text-align: left;
            position: relative;
        }

        .input-group label {
            display: block;
            margin-bottom: 0.8rem;
            font-weight: 700;
            color: rgba(255, 255, 255, 0.9);
            font-size: 1.1rem;
            letter-spacing: 0.5px;
            text-transform: uppercase;
            font-family: 'Rajdhani', sans-serif;
        }

        .input-group input, .input-group select {
            width: 100%;
            padding: 1.1rem 1.5rem;
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(10px);
            border: 2px solid rgba(255, 165, 0, 0.2);
            border-radius: 15px;
            font-size: 1.1rem;
            font-family: 'Rajdhani', sans-serif;
            color: rgba(255, 255, 255, 0.95);
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
        }

        .input-group input::placeholder {
            color: rgba(255, 255, 255, 0.4);
        }

        .input-group input:hover, .input-group select:hover {
            background: rgba(255, 255, 255, 0.08);
            border-color: rgba(255, 165, 0, 0.5);
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(255, 165, 0, 0.15);
        }

        .input-group input:focus, .input-group select:focus {
            outline: none;
            background: rgba(255, 255, 255, 0.1);
            border-color: #ffa500;
            box-shadow: 0 0 0 4px rgba(255, 165, 0, 0.2), 0 10px 30px rgba(255, 165, 0, 0.3);
            transform: translateY(-3px);
        }

        .btn-primary {
            background: linear-gradient(135deg, #ffa500 0%, #ff6b35 100%);
            color: #1a1a2e;
            border: none;
            padding: 1.2rem 3rem;
            border-radius: 50px;
            font-family: 'Russo One', sans-serif;
            font-size: 1.2rem;
            font-weight: 900;
            cursor: pointer;
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: 0 10px 30px rgba(255, 165, 0, 0.4);
            text-transform: uppercase;
            letter-spacing: 2px;
            position: relative;
            overflow: hidden;
        }

        .btn-primary::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.4), transparent);
            transition: left 0.5s ease;
        }

        .btn-primary:hover::before {
            left: 100%;
        }

        .btn-primary:hover {
            transform: translateY(-5px) scale(1.02);
            box-shadow: 0 15px 40px rgba(255, 165, 0, 0.6);
            background: linear-gradient(135deg, #ff6b35 0%, #ffa500 100%);
        }

        .btn-primary:active {
            transform: translateY(-2px) scale(0.98);
        }

        .btn-primary:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .admin-link {
            margin-top: 1.5rem;
            color: #ffa500;
            text-decoration: none;
            font-weight: 700;
            font-size: 1rem;
            letter-spacing: 0.5px;
            transition: all 0.3s ease;
            display: inline-block;
        }

        .admin-link:hover {
            color: #ff6b35;
            text-decoration: none;
            transform: translateX(5px);
            text-shadow: 0 0 10px rgba(255, 165, 0, 0.5);
        }

        /* Tab Navigation */
        .tab-navigation {
            display: flex;
            justify-content: center;
            gap: 0;
            background: var(--white);
            margin: 2rem auto;
            max-width: 800px;
            border-radius: 15px;
            overflow: hidden;
            box-shadow: var(--shadow-md);
        }

        .tab-btn {
            flex: 1;
            padding: 1.2rem 2rem;
            background: var(--white);
            color: var(--text-gray);
            border: none;
            cursor: pointer;
            font-family: 'Russo One', sans-serif;
            font-size: 1.1rem;
            text-transform: uppercase;
            letter-spacing: 1px;
            transition: all 0.3s ease;
            position: relative;
        }

        .tab-btn:after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 3px;
            background: var(--primary-blue);
            transform: scaleX(0);
            transition: transform 0.3s ease;
        }

        .tab-btn.active {
            color: var(--primary-blue);
            background: var(--light-blue);
        }

        .tab-btn.active:after {
            transform: scaleX(1);
        }

        .tab-btn:hover {
            background: var(--light-blue);
        }

        .container {
            max-width: 1200px;
            margin: 2rem auto;
            padding: 0 1rem;
        }

        .hidden {
            display: none !important;
        }

        /* Match Cards */
        .matches-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(350px, 1fr));
            gap: 1.5rem;
        }

        .match-card {
            background: var(--white);
            border-radius: 15px;
            padding: 1.5rem;
            box-shadow: var(--shadow-md);
            transition: all 0.3s ease;
            border: 2px solid transparent;
        }

        .match-card:hover {
            transform: translateY(-5px);
            box-shadow: var(--shadow-lg);
            border-color: var(--primary-blue);
        }

        .match-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
            padding-bottom: 0.8rem;
            border-bottom: 2px solid var(--light-blue);
        }

        .match-status-badge {
            padding: 0.4rem 1rem;
            border-radius: 20px;
            font-size: 0.85rem;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .badge-upcoming {
            background: var(--light-blue);
            color: var(--primary-blue);
        }

        .badge-completed {
            background: var(--success-green);
            color: var(--white);
        }

        .match-time {
            font-size: 0.9rem;
            color: var(--text-gray);
            font-weight: 600;
        }

        .teams-container {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin: 1.5rem 0;
            gap: 1rem;
        }

        .team {
            flex: 1;
            text-align: center;
            cursor: pointer;
            padding: 1rem;
            border-radius: 12px;
            transition: all 0.3s ease;
            border: 3px solid transparent;
        }

        .team:hover {
            background: var(--light-blue);
        }

        .team.selected {
            background: var(--light-blue);
            border-color: var(--primary-blue);
            transform: scale(1.05);
        }

        .team.disabled {
            cursor: not-allowed;
            opacity: 0.5;
        }

        .team-flag {
            font-size: 3.5rem;
            margin-bottom: 0.5rem;
        }

        .team-flag img {
            width: 56px;
            height: 42px;
            object-fit: cover;
            border-radius: 4px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }

        .team-name {
            font-family: 'Russo One', sans-serif;
            font-size: 1.2rem;
            color: var(--text-dark);
            margin-bottom: 0.3rem;
        }

        .vs-divider {
            font-family: 'Bebas Neue', cursive;
            font-size: 2rem;
            color: var(--primary-blue);
            font-weight: bold;
        }

        .venue-info {
            background: var(--light-blue);
            padding: 0.8rem;
            border-radius: 10px;
            margin: 1rem 0;
            text-align: center;
        }

        .venue-name {
            font-weight: 600;
            color: var(--primary-blue);
            font-size: 1rem;
        }

        .countdown {
            text-align: center;
            margin: 1rem 0;
            padding: 1rem;
            background: linear-gradient(135deg, var(--warning-orange) 0%, #ff6b35 100%);
            border-radius: 10px;
            color: var(--white);
            font-family: 'Russo One', sans-serif;
        }

        .countdown-label {
            font-size: 0.85rem;
            margin-bottom: 0.3rem;
            opacity: 0.9;
        }

        .countdown-time {
            font-size: 1.5rem;
            font-weight: bold;
        }

        .prediction-stats-container {
            display: flex;
            gap: 0.5rem;
            margin: 1rem 0;
        }

        .prediction-stat-box {
            flex: 1;
            padding: 0.8rem;
            background: linear-gradient(135deg, var(--primary-blue) 0%, var(--secondary-blue) 100%);
            color: white;
            border-radius: 10px;
            text-align: center;
        }

        .prediction-stat-label {
            font-size: 0.75rem;
            opacity: 0.9;
            margin-bottom: 0.3rem;
            text-transform: uppercase;
        }

        .prediction-stat-value {
            font-size: 1.2rem;
            font-weight: bold;
        }

        .match-points-badge {
            display: inline-block;
            background: linear-gradient(135deg, #ffd700 0%, #ffed4e 100%);
            color: #000;
            padding: 0.3rem 0.7rem;
            border-radius: 15px;
            font-weight: 700;
            font-size: 0.85rem;
            border: 2px solid #ffa500;
        }

        .user-predictor-box {
            background: linear-gradient(135deg, var(--primary-blue) 0%, var(--secondary-blue) 100%);
            color: white;
            padding: 1rem;
            border-radius: 10px;
            margin: 1rem 0;
            text-align: center;
        }

        .user-predictor-title {
            font-size: 0.85rem;
            opacity: 0.9;
            margin-bottom: 0.7rem;
            text-transform: uppercase;
            font-weight: 600;
            letter-spacing: 0.5px;
        }

        .user-predictor-stats {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 1.5rem;
        }

        .predictor-team {
            display: flex;
            flex-direction: column;
            gap: 0.3rem;
        }

        .predictor-team-name {
            font-size: 0.9rem;
            font-weight: 600;
        }

        .predictor-team-percent {
            font-size: 1.5rem;
            font-weight: 700;
        }

        .predictor-divider {
            font-size: 1.5rem;
            opacity: 0.5;
        }

        .team-prediction-bar {
            height: 6px;
            background: var(--border-gray);
            border-radius: 3px;
            margin-top: 0.5rem;
            position: relative;
            overflow: hidden;
        }

        .team-prediction-fill {
            position: absolute;
            left: 0;
            top: 0;
            height: 100%;
            background: linear-gradient(135deg, var(--primary-blue) 0%, var(--accent-blue) 100%);
            transition: width 0.3s ease;
        }

        .team-prediction-percent {
            font-size: 0.75rem;
            color: var(--primary-blue);
            font-weight: 600;
            margin-top: 0.3rem;
        }

        .prediction-status {
            margin: 1rem 0;
            padding: 0.8rem;
            border-radius: 10px;
            text-align: center;
            font-weight: 600;
        }

        .prediction-pending {
            background: #fff3cd;
            color: #856404;
        }

        .prediction-correct {
            background: #d4edda;
            color: #155724;
        }

        .prediction-incorrect {
            background: #f8d7da;
            color: #721c24;
        }

        /* Leaderboard */
        .leaderboard-container {
            background: var(--white);
            border-radius: 15px;
            padding: 2rem;
            box-shadow: var(--shadow-md);
        }

        .leaderboard-header {
            text-align: center;
            margin-bottom: 2rem;
        }

        .leaderboard-header h2 {
            font-family: 'Bebas Neue', cursive;
            font-size: 2.5rem;
            color: var(--primary-blue);
            letter-spacing: 2px;
        }

        .table-container {
            overflow-x: auto;
            -webkit-overflow-scrolling: touch;
            border-radius: 10px;
            box-shadow: var(--shadow-sm);
        }

        .leaderboard-table {
            width: 100%;
            border-collapse: collapse;
        }

        .leaderboard-table thead {
            background: linear-gradient(135deg, var(--primary-blue) 0%, var(--secondary-blue) 100%);
            color: var(--white);
        }

        .leaderboard-table th {
            padding: 1.2rem;
            text-align: left;
            font-family: 'Russo One', sans-serif;
            font-size: 1rem;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .leaderboard-table td {
            padding: 1.2rem;
            border-bottom: 1px solid var(--border-gray);
            font-size: 1.1rem;
            font-weight: 500;
        }

        .leaderboard-table tbody tr {
            transition: all 0.3s ease;
        }

        .leaderboard-table tbody tr:hover {
            background: var(--light-blue);
            transform: scale(1.02);
        }

        .current-user-row {
            background: rgba(0, 71, 171, 0.1) !important;
            border-left: 5px solid var(--primary-blue);
            font-weight: 700;
        }

        .rank-badge {
            display: inline-block;
            width: 40px;
            height: 40px;
            line-height: 40px;
            text-align: center;
            border-radius: 50%;
            background: var(--primary-blue);
            color: var(--white);
            font-family: 'Russo One', sans-serif;
            font-size: 1.1rem;
        }

        .rank-badge.gold {
            background: linear-gradient(135deg, #FFD700 0%, #FFA500 100%);
            font-size: 1.3rem;
        }

        .rank-badge.silver {
            background: linear-gradient(135deg, #C0C0C0 0%, #808080 100%);
            font-size: 1.2rem;
        }

        .rank-badge.bronze {
            background: linear-gradient(135deg, #CD7F32 0%, #8B4513 100%);
            font-size: 1.2rem;
        }

        /* Admin Panel */
        .admin-panel {
            background: var(--white);
            border-radius: 15px;
            padding: 2rem;
            box-shadow: var(--shadow-md);
            margin-bottom: 2rem;
        }

        .admin-panel h2 {
            font-family: 'Bebas Neue', cursive;
            font-size: 2rem;
            color: var(--primary-blue);
            margin-bottom: 1.5rem;
        }

        .form-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 1.5rem;
            margin-bottom: 1.5rem;
        }

        /* Admin Panel Input Fields - Override login page styles */
        .admin-panel .input-group input,
        .admin-panel .input-group select {
            background: var(--white);
            color: var(--text-dark);
            border: 2px solid var(--border-gray);
        }

        .admin-panel .input-group input:hover,
        .admin-panel .input-group select:hover {
            background: var(--white);
            border-color: var(--primary-blue);
            box-shadow: 0 2px 8px rgba(0, 71, 171, 0.1);
        }

        .admin-panel .input-group input:focus,
        .admin-panel .input-group select:focus {
            background: var(--white);
            border-color: var(--primary-blue);
            box-shadow: 0 0 0 3px rgba(0, 71, 171, 0.1);
        }

        .admin-panel .input-group input::placeholder {
            color: var(--text-gray);
        }

        .admin-panel .input-group label {
            color: var(--text-dark);
        }

        .team-select {
            position: relative;
        }

        .team-select-input {
            width: 100%;
            padding: 0.9rem 1.2rem;
            border: 2px solid var(--border-gray);
            border-radius: 10px;
            font-size: 1.1rem;
            cursor: pointer;
            background: white;
        }

        .team-dropdown {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: white;
            border: 2px solid var(--primary-blue);
            border-radius: 10px;
            max-height: 300px;
            overflow-y: auto;
            z-index: 1000;
            box-shadow: var(--shadow-lg);
            display: none;
        }

        .team-dropdown.show {
            display: block;
        }

        .team-option {
            padding: 1rem 1.2rem;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 0.8rem;
        }

        .team-option:hover {
            background: var(--light-blue);
        }

        .team-option-flag {
            font-size: 1.8rem;
            display: flex;
            align-items: center;
        }

        .team-option-flag img {
            width: 32px;
            height: 24px;
            object-fit: cover;
            border-radius: 3px;
        }

        .team-option-name {
            font-weight: 600;
            font-size: 1.1rem;
        }

        .search-input {
            width: 100%;
            padding: 0.8rem;
            border: none;
            border-bottom: 2px solid var(--border-gray);
            font-size: 1rem;
            position: sticky;
            top: 0;
            background: white;
        }

        .search-input:focus {
            outline: none;
            border-bottom-color: var(--primary-blue);
        }

        .btn-success {
            background: var(--success-green);
            color: white;
            border: none;
            padding: 1rem 2rem;
            border-radius: 10px;
            cursor: pointer;
            font-family: 'Rajdhani', sans-serif;
            font-weight: 600;
            font-size: 1.1rem;
            transition: all 0.3s ease;
        }

        .btn-success:hover {
            background: #218838;
            transform: translateY(-2px);
        }

        .btn-danger {
            background: var(--error-red);
            color: white;
            border: none;
            padding: 0.5rem 1rem;
            border-radius: 8px;
            cursor: pointer;
            font-family: 'Rajdhani', sans-serif;
            font-weight: 600;
            transition: all 0.3s ease;
        }

        .btn-danger:hover {
            background: #c82333;
        }

        .matches-list {
            margin-top: 2rem;
        }

        .admin-match-card {
            background: var(--light-blue);
            padding: 1.5rem;
            border-radius: 10px;
            margin-bottom: 1rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .admin-match-info {
            flex: 1;
        }

        .admin-match-teams {
            font-size: 1.3rem;
            font-weight: 700;
            color: var(--primary-blue);
            margin-bottom: 0.5rem;
        }

        .admin-match-details {
            color: var(--text-gray);
            font-size: 0.95rem;
        }

        .admin-actions {
            display: flex;
            gap: 0.5rem;
        }

        /* Users Management Styles */
        .users-table {
            width: 100%;
            border-collapse: collapse;
            background: var(--white);
            border-radius: 10px;
            overflow: hidden;
            box-shadow: var(--shadow-sm);
        }

        .users-table thead {
            background: linear-gradient(135deg, var(--primary-blue) 0%, var(--secondary-blue) 100%);
            color: var(--white);
        }

        .users-table th {
            padding: 1.2rem;
            text-align: left;
            font-weight: 700;
            font-size: 1.1rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .users-table td {
            padding: 1.2rem;
            border-bottom: 1px solid var(--border-gray);
            color: var(--text-dark);
            font-size: 1.05rem;
        }

        .users-table tbody tr:hover {
            background: var(--light-blue);
            transition: all 0.3s ease;
        }

        .users-table tbody tr:last-child td {
            border-bottom: none;
        }

        .user-badge {
            display: inline-block;
            padding: 0.3rem 0.8rem;
            border-radius: 15px;
            font-size: 0.85rem;
            font-weight: 700;
            text-transform: uppercase;
        }

        .user-badge.admin {
            background: #ffd700;
            color: #000;
        }

        .user-badge.user {
            background: var(--light-blue);
            color: var(--primary-blue);
        }

        .user-badge.pending-reset {
            background: #ff9800;
            color: var(--white);
        }

        .btn-reset {
            background: var(--warning-orange);
            color: var(--white);
            border: none;
            padding: 0.5rem 1rem;
            border-radius: 5px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s ease;
        }

        .btn-reset:hover {
            background: #e68900;
            transform: translateY(-2px);
        }

        .btn-delete-user {
            background: var(--error-red);
            color: var(--white);
            border: none;
            padding: 0.5rem 1rem;
            border-radius: 5px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s ease;
            margin-left: 0.5rem;
        }

        .btn-delete-user:hover {
            background: #c82333;
            transform: translateY(-2px);
        }

        .result-selector {
            margin-top: 1rem;
            padding: 1rem;
            background: white;
            border-radius: 8px;
        }

        .result-buttons {
            display: flex;
            gap: 1rem;
            margin-top: 0.5rem;
        }

        .result-btn {
            flex: 1;
            padding: 0.8rem;
            border: 2px solid var(--border-gray);
            background: white;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s ease;
        }

        .result-btn:hover {
            background: var(--light-blue);
            border-color: var(--primary-blue);
        }

        .result-btn.selected {
            background: var(--primary-blue);
            color: white;
            border-color: var(--primary-blue);
        }

        .tg-update-section {
            margin-top: 1rem;
            padding: 1rem;
            background: linear-gradient(135deg, #e8f5e9 0%, #c8e6c9 100%);
            border: 2px solid #4caf50;
            border-radius: 8px;
        }

        .tg-update-section strong {
            color: #2e7d32;
        }

        .tg-update-buttons {
            display: flex;
            gap: 0.5rem;
            margin-top: 0.5rem;
            flex-wrap: wrap;
        }

        .tg-btn {
            padding: 0.5rem 0.8rem;
            border: 2px solid #a5d6a7;
            background: white;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            font-family: 'Rajdhani', sans-serif;
            font-size: 0.9rem;
            transition: all 0.3s ease;
        }

        .tg-btn:hover {
            background: #4caf50;
            color: white;
            border-color: #4caf50;
        }

        .success-message, .error-message, .warning-message {
            padding: 1.5rem;
            border-radius: 12px;
            margin: 1rem 0;
            font-weight: 600;
        }

        .success-message {
            background: #d4edda;
            color: #155724;
            border-left: 5px solid var(--success-green);
        }

        .error-message {
            background: #f8d7da;
            color: #721c24;
            border-left: 5px solid var(--error-red);
        }

        .warning-message {
            background: #fff3cd;
            color: #856404;
            border-left: 5px solid var(--warning-orange);
        }

        .empty-state {
            text-align: center;
            padding: 3rem;
            color: var(--text-gray);
        }

        .empty-state h3 {
            font-size: 1.5rem;
            margin-bottom: 1rem;
        }

        @media (max-width: 968px) {
            .login-container {
                grid-template-columns: 1fr;
            }

            .login-right {
                display: none;
            }

            .login-left {
                min-height: 100vh;
            }

            .login-container h2 {
                font-size: 2.8rem;
            }
        }

        @media (max-width: 768px) {
            body {
                font-size: 14px;
            }

            .header {
                padding: 0.8rem 1rem;
                flex-wrap: wrap;
            }

            .header-logo {
                width: 40px;
                height: 40px;
                border-radius: 8px;
            }

            .header-text h1 {
                font-size: 1.3rem;
            }

            .header-text .subtitle {
                font-size: 0.8rem;
            }

            .user-info {
                gap: 0.5rem;
            }

            .user-info span {
                font-size: 0.85rem;
            }

            .logout-btn {
                padding: 0.3rem 0.8rem;
                font-size: 0.85rem;
            }

            .login-container h2 {
                font-size: 2.2rem;
            }

            .login-container p {
                font-size: 1rem;
                margin-bottom: 1.5rem;
            }

            .login-form-wrapper {
                max-width: 100%;
                padding: 1rem;
            }

            .login-left {
                padding: 1.5rem 1rem;
            }

            .logo-glass-card {
                padding: 2rem 1rem;
            }

            .logo-glass-card img {
                max-width: 300px;
            }

            .logo-glass-card .trophy-icon {
                font-size: 6rem;
            }

            .logo-glass-card .trophy-text {
                font-size: 1.5rem;
                margin-top: 1rem;
            }

            .input-group input,
            .input-group select {
                padding: 0.9rem 1rem;
                font-size: 1rem;
            }

            .btn-primary {
                padding: 1rem 2rem;
                font-size: 1rem;
            }

            .container {
                padding: 1rem;
            }

            .matches-grid {
                grid-template-columns: 1fr;
                gap: 1rem;
            }

            .match-card {
                padding: 1rem;
            }

            .match-header {
                flex-direction: column;
                align-items: flex-start;
                gap: 0.5rem;
            }

            .match-status-badge {
                font-size: 0.75rem;
                padding: 0.3rem 0.6rem;
            }

            .match-time {
                font-size: 0.85rem;
            }

            .team-flag {
                font-size: 2.5rem;
            }

            .team-flag img {
                width: 44px;
                height: 33px;
            }

            .team-name {
                font-size: 1rem;
            }

            .vs-divider {
                font-size: 1rem;
                padding: 0.5rem;
            }

            .countdown {
                padding: 0.8rem;
            }

            .countdown-label {
                font-size: 0.85rem;
            }

            .countdown-time {
                font-size: 1.1rem;
            }

            .tab-navigation {
                flex-wrap: wrap;
                gap: 0.3rem;
            }

            .tab-btn {
                padding: 0.8rem 1rem;
                font-size: 0.9rem;
                flex: 1 1 45%;
            }

            .user-predictor-box {
                padding: 0.8rem;
            }

            .user-predictor-stats {
                gap: 1rem;
            }

            .predictor-team-name {
                font-size: 0.8rem;
            }

            .predictor-team-percent {
                font-size: 1.3rem;
            }

            .leaderboard-table {
                font-size: 0.85rem;
            }

            .leaderboard-table th,
            .leaderboard-table td {
                padding: 0.8rem 0.5rem;
            }

            .rank-badge {
                width: 30px;
                height: 30px;
                font-size: 0.85rem;
            }

            .admin-panel {
                padding: 1rem;
            }

            .admin-panel h2 {
                font-size: 1.3rem;
            }

            .form-grid {
                grid-template-columns: 1fr;
            }

            .admin-match-card {
                padding: 1rem;
                flex-direction: column;
                gap: 1rem;
            }

            .admin-match-teams {
                font-size: 0.95rem;
            }

            .admin-match-teams img {
                width: 24px;
                height: 18px;
            }

            .admin-match-details {
                font-size: 0.8rem;
            }

            .admin-actions {
                flex-direction: column;
            }

            .btn-danger,
            .btn-reset {
                font-size: 0.85rem;
                padding: 0.5rem 0.8rem;
            }

            .users-table {
                font-size: 0.8rem;
            }

            .users-table th,
            .users-table td {
                padding: 0.8rem 0.4rem;
            }

            .btn-delete-user,
            .btn-reset {
                font-size: 0.75rem;
                padding: 0.4rem 0.6rem;
                margin-left: 0.3rem;
            }

            .result-buttons {
                flex-direction: column;
            }

            .result-btn {
                padding: 0.6rem;
                font-size: 0.9rem;
            }
        }

        /* Extra small devices (phones in portrait mode) */
        @media (max-width: 480px) {
            .header-text h1 {
                font-size: 1.1rem;
            }

            .header-text .subtitle {
                font-size: 0.7rem;
            }

            .header-logo {
                width: 35px;
                height: 35px;
            }

            .login-container h2 {
                font-size: 1.8rem;
            }

            .logo-glass-card .trophy-icon {
                font-size: 5rem;
            }

            .logo-glass-card .trophy-text {
                font-size: 1.2rem;
            }

            .team-flag {
                font-size: 2rem;
            }

            .team-flag img {
                width: 36px;
                height: 27px;
            }

            .team-name {
                font-size: 0.9rem;
            }

            .tab-btn {
                font-size: 0.8rem;
                padding: 0.7rem 0.8rem;
            }

            .leaderboard-table {
                font-size: 0.75rem;
            }

            .rank-badge {
                width: 25px;
                height: 25px;
                font-size: 0.75rem;
            }

            /* Make tables scrollable on very small screens */
            .table-container {
                overflow-x: auto;
                -webkit-overflow-scrolling: touch;
            }

            .users-table,
            .leaderboard-table {
                min-width: 500px;
            }
        }

        /* Landscape mode for mobile devices */
        @media (max-height: 600px) and (orientation: landscape) {
            .login-left {
                padding: 1rem;
            }

            .login-container h2 {
                font-size: 1.8rem;
                margin-bottom: 0.3rem;
            }

            .login-container p {
                margin-bottom: 1rem;
            }

            .login-form {
                gap: 1rem;
            }

            .input-group input,
            .input-group select {
                padding: 0.7rem 1rem;
            }
        }
    </style>
</head>
<body>

    <!-- LOGIN PAGE -->
    <div id="loginPage" class="login-container">
        <!-- LEFT SIDE - Login Form -->
        <div class="login-left">
            <div class="login-form-wrapper">
                <h2>T20 WORLD CUP</h2>
                <p>Villa Hakatha Prediction League 2026</p>

                <div class="login-form">
                    <div class="input-group">
                        <label for="loginUsername">üë§ Username</label>
                        <input type="text" id="loginUsername" placeholder="Enter your username" maxlength="30">
                    </div>

                    <div class="input-group">
                        <label for="loginPassword">üîê Password</label>
                        <input type="password" id="loginPassword" placeholder="Enter your password">
                    </div>

                    <button class="btn-primary" onclick="login()">Let's Go üöÄ</button>
                </div>

                <a href="#" class="admin-link" onclick="showRegisterPage(); return false;">New User? Register Here ‚Üí</a>

                <div id="loginError" class="error-message hidden"></div>
            </div>
        </div>

        <!-- RIGHT SIDE - Glassmorphism Logo -->
        <div class="login-right">
            <div class="logo-glass-card">
                <img src="t20-worldcup-logo.png" alt="T20 World Cup 2026" onerror="this.style.display='none'; this.nextElementSibling.style.display='block';">
                <div style="display: none;">
                    <div class="trophy-icon">üèÜ</div>
                    <div class="trophy-text">T20 WORLD CUP<br>2026</div>
                </div>
            </div>
        </div>
    </div>

    <!-- REGISTER PAGE -->
    <div id="registerPage" class="login-container hidden">
        <!-- LEFT SIDE - Register Form -->
        <div class="login-left">
            <div class="login-form-wrapper">
                <h2>REGISTER</h2>
                <p>Create Your Prediction Account</p>

                <div class="login-form">
                    <div class="input-group">
                        <label for="registerUsername">üë§ Username</label>
                        <input type="text" id="registerUsername" placeholder="Choose a username" maxlength="30">
                    </div>

                    <div class="input-group">
                        <label for="registerPhone">üì± Contact Number</label>
                        <div style="display: flex; gap: 0.5rem; align-items: center;">
                            <span style="padding: 0.9rem 1rem; background: rgba(255,255,255,0.1); border: 2px solid rgba(255,165,0,0.3); border-radius: 10px; font-weight: 600; color: rgba(255,255,255,0.9); white-space: nowrap;">+960</span>
                            <input type="tel" id="registerPhone" placeholder="7654321" maxlength="7" pattern="[0-9]{7}" style="flex: 1;">
                        </div>
                        <small style="color: var(--text-gray); margin-top: 0.3rem; display: block;">7 digits only (e.g., 7654321)</small>
                    </div>

                    <div class="input-group">
                        <label for="registerPassword">üîê Password</label>
                        <input type="password" id="registerPassword" placeholder="Create a password">
                    </div>

                    <div class="input-group">
                        <label for="registerConfirmPassword">üîê Confirm Password</label>
                        <input type="password" id="registerConfirmPassword" placeholder="Confirm your password">
                    </div>

                    <button class="btn-primary" onclick="register()">Create Account üéØ</button>
                </div>

                <a href="#" class="admin-link" onclick="showLoginPage(); return false;">‚Üê Back to Login</a>

                <div id="registerError" class="error-message hidden"></div>
            </div>
        </div>

        <!-- RIGHT SIDE - Glassmorphism Logo -->
        <div class="login-right">
            <div class="logo-glass-card">
                <img src="t20-worldcup-logo.png" alt="T20 World Cup 2026" onerror="this.style.display='none'; this.nextElementSibling.style.display='block';">
                <div style="display: none;">
                    <div class="trophy-icon">üèÜ</div>
                    <div class="trophy-text">T20 WORLD CUP<br>2026</div>
                </div>
            </div>
        </div>
    </div>

    <!-- MAIN APPLICATION -->
    <div id="mainApp" class="hidden">
        <div class="header">
            <div class="header-left">
                <img src="t20-worldcup-logo.png" alt="T20 World Cup 2026" class="header-logo" onerror="this.style.display='none';">
                <div class="header-text">
                    <h1>T20 World Cup 2026</h1>
                    <div class="subtitle">Villa Hakatha Prediction League | <a href="#" onclick="showHowItWorks(); return false;" style="color: #ffd700; text-decoration: none;">How it works?</a> | <a href="https://t.me/+2Z7FQh3yg-o5OTRl" target="_blank" style="color: #0088cc; text-decoration: none;">üì¢ Telegram</a></div>
                </div>
            </div>
            <div class="user-info">
                <span id="adminBadge" class="admin-badge hidden">ADMIN</span>
                <span id="userDisplay"></span>
                <button class="logout-btn" onclick="logout()">Logout</button>
            </div>
        </div>

        <!-- Tab Navigation -->
        <div class="tab-navigation">
            <button class="tab-btn active" onclick="switchTab('predictions')">Match Predictions</button>
            <button class="tab-btn" onclick="switchTab('leaderboard')">Leaderboard</button>
            <button id="adminTabBtn" class="tab-btn hidden" onclick="switchTab('admin')">Matches</button>
            <button id="usersTabBtn" class="tab-btn hidden" onclick="switchTab('users')">Users</button>
        </div>

        <div class="container">
            <!-- PREDICTIONS TAB -->
            <div id="predictionsTab">
                <!-- How It Works Notification Box -->
                <div id="howItWorksBox" class="admin-panel" style="background: linear-gradient(135deg, #e3f2fd 0%, #bbdefb 100%); border: 3px solid var(--primary-blue); margin-bottom: 1.5rem; position: relative;">
                    <button onclick="closeHowItWorks()" style="position: absolute; top: 0.8rem; right: 0.8rem; background: var(--primary-blue); color: white; border: none; width: 28px; height: 28px; border-radius: 50%; cursor: pointer; font-size: 1.1rem; font-weight: bold;">√ó</button>
                    <h2 style="color: var(--primary-blue); margin-bottom: 1rem;">üèè How Predictions Work</h2>

                    <div style="color: var(--text-dark); line-height: 1.6;">
                        <p style="margin-bottom: 0.8rem;"><strong>Making a Prediction</strong></p>
                        <ul style="margin-left: 1.2rem; margin-bottom: 1rem;">
                            <li>Tap on the team you think will win the match</li>
                            <li>Your selection will be highlighted with a blue border</li>
                            <li>Tap the same team again to remove your prediction</li>
                        </ul>

                        <p style="margin-bottom: 0.8rem;"><strong>‚è∞ Prediction Deadline</strong></p>
                        <ul style="margin-left: 1.2rem; margin-bottom: 1rem;">
                            <li>Submit your prediction <strong>at least 30 minutes before</strong> match starts</li>
                            <li>Once countdown shows less than 30 min, predictions are <strong>locked</strong> (shown in red)</li>
                        </ul>

                        <p style="margin-bottom: 0.8rem;"><strong>‚≠ê Points System</strong></p>
                        <ul style="margin-left: 1.2rem; margin-bottom: 1rem;">
                            <li>Each match has a point value (1-5 stars) shown on the match card</li>
                            <li>If your prediction is correct, you earn the match's point value</li>
                        </ul>

                        <p style="margin-bottom: 0.8rem;"><strong>üìä Leaderboard</strong></p>
                        <ul style="margin-left: 1.2rem; margin-bottom: 1rem;">
                            <li>Your total points are displayed on the Leaderboard tab</li>
                            <li>Rankings sorted by total points (highest first)</li>
                            <li>If tied, user with more correct predictions ranks higher</li>
                        </ul>

                        <p style="margin-bottom: 0.8rem;"><strong>üîî Prediction Status</strong></p>
                        <ul style="margin-left: 1.2rem; margin-bottom: 1rem;">
                            <li>‚è≥ Pending - Match hasn't been played yet</li>
                            <li>‚úÖ Correct - You predicted correctly (+points)</li>
                            <li>‚ùå Incorrect - Wrong prediction (0 points)</li>
                        </ul>

                        <p style="margin-bottom: 0.8rem;"><strong>üí° Tips</strong></p>
                        <ul style="margin-left: 1.2rem;">
                            <li>Check the app daily for new matches</li>
                            <li>Predict early to avoid missing the deadline</li>
                            <li>Higher-stakes matches (knockouts) are worth more points!</li>
                        </ul>
                    </div>
                </div>

                <div id="messageContainer"></div>

                <div id="matchesContainer" class="matches-grid"></div>

                <div id="noMatchesMsg" class="empty-state hidden">
                    <h3>No Matches Scheduled</h3>
                    <p>Admin will add matches soon!</p>
                </div>
            </div>

            <!-- LEADERBOARD TAB -->
            <div id="leaderboardTab" class="hidden">
                <div class="leaderboard-container">
                    <div class="leaderboard-header">
                        <h2>üèÜ Top Predictors</h2>
                        <p style="color: var(--text-gray); font-size: 1.1rem; margin-top: 0.5rem;">
                            Compete for the top spot!
                        </p>
                    </div>

                    <div class="table-container">
                        <table class="leaderboard-table">
                            <thead>
                                <tr>
                                    <th>Rank</th>
                                    <th>Player</th>
                                    <th>Points</th>
                                    <th>Accuracy %</th>
                                    <th id="leaderboardActionsHeader" class="hidden">Actions</th>
                                </tr>
                            </thead>
                            <tbody id="leaderboardBody"></tbody>
                        </table>
                    </div>
                </div>
            </div>

            <!-- ADMIN PANEL TAB -->
            <div id="adminTab" class="hidden">
                <div class="admin-panel">
                    <h2>‚ûï Add New Match</h2>

                    <div class="form-grid">
                        <!-- Team 1 -->
                        <div class="input-group">
                            <label>Team 1</label>
                            <div class="team-select">
                                <div class="team-select-input" onclick="toggleTeamDropdown('team1')" id="team1Display">
                                    Select Team 1
                                </div>
                                <div class="team-dropdown" id="team1Dropdown">
                                    <input type="text" class="search-input" placeholder="üîç Search team..." onkeyup="filterTeams('team1', this.value)">
                                    <div id="team1Options"></div>
                                </div>
                            </div>
                        </div>

                        <!-- Team 2 -->
                        <div class="input-group">
                            <label>Team 2</label>
                            <div class="team-select">
                                <div class="team-select-input" onclick="toggleTeamDropdown('team2')" id="team2Display">
                                    Select Team 2
                                </div>
                                <div class="team-dropdown" id="team2Dropdown">
                                    <input type="text" class="search-input" placeholder="üîç Search team..." onkeyup="filterTeams('team2', this.value)">
                                    <div id="team2Options"></div>
                                </div>
                            </div>
                        </div>

                        <!-- Date -->
                        <div class="input-group">
                            <label for="matchDate">Date</label>
                            <input type="date" id="matchDate">
                        </div>

                        <!-- Time -->
                        <div class="input-group">
                            <label for="matchTime">Time</label>
                            <input type="time" id="matchTime">
                        </div>

                        <!-- Match Stage/Group -->
                        <div class="input-group">
                            <label for="matchStage">Match Stage</label>
                            <select id="matchStage">
                                <option value="group">Group Stage</option>
                                <option value="super8">Super 8</option>
                                <option value="semi">Semi Final</option>
                                <option value="final">Final</option>
                            </select>
                        </div>
                    </div>

                    <button class="btn-success" onclick="addMatch()">‚ûï Add Match</button>
                </div>

                <!-- Push Link to Telegram -->
                <div class="admin-panel" style="background: linear-gradient(135deg, #e8f5e9 0%, #c8e6c9 100%); border: 2px solid #4caf50;">
                    <h2 style="color: #2e7d32;">üì¢ Push to Telegram Group</h2>
                    <div style="display: flex; gap: 0.8rem; align-items: center; flex-wrap: wrap;">
                        <input type="text" id="pushLinkInput" placeholder="Paste Cricbuzz / ESPN live score link here..." style="flex: 1; min-width: 250px; padding: 0.8rem 1rem; border: 2px solid #a5d6a7; border-radius: 8px; font-size: 1rem; font-family: 'Rajdhani', sans-serif;">
                        <button onclick="pushLinkToTelegram()" style="background: #4caf50; color: white; border: none; padding: 0.8rem 1.5rem; border-radius: 8px; font-weight: 700; font-size: 1rem; cursor: pointer; font-family: 'Rajdhani', sans-serif; white-space: nowrap;">üì¢ Send Link</button>
                        <button onclick="pushCustomMessage()" style="background: #2196f3; color: white; border: none; padding: 0.8rem 1.5rem; border-radius: 8px; font-weight: 700; font-size: 1rem; cursor: pointer; font-family: 'Rajdhani', sans-serif; white-space: nowrap;">‚úèÔ∏è Custom Message</button>
                    </div>
                </div>

                <!-- Scheduled Matches List -->
                <div class="admin-panel">
                    <h2>üìã Scheduled Matches</h2>
                    <div id="adminMatchesList" class="matches-list"></div>
                </div>
            </div>

            <!-- USERS MANAGEMENT TAB -->
            <div id="usersTab" class="hidden">
                <div class="admin-panel">
                    <h2>‚ûï Add New User</h2>

                    <div class="form-grid">
                        <div class="input-group">
                            <label for="newUserUsername">Username</label>
                            <input type="text" id="newUserUsername" placeholder="Enter username" maxlength="30">
                        </div>

                        <div class="input-group">
                            <label for="newUserPhone">Contact Number</label>
                            <div style="display: flex; gap: 0.5rem; align-items: center;">
                                <span style="padding: 0.9rem 1rem; background: var(--light-blue); border: 2px solid var(--border-gray); border-radius: 10px; font-weight: 600; color: var(--primary-blue); white-space: nowrap;">+960</span>
                                <input type="tel" id="newUserPhone" placeholder="7654321" maxlength="7" pattern="[0-9]{7}" style="flex: 1;">
                            </div>
                        </div>

                        <div class="input-group">
                            <label for="newUserPassword">Password</label>
                            <input type="password" id="newUserPassword" placeholder="Enter password">
                        </div>
                    </div>

                    <button class="btn-success" onclick="addUser()">‚ûï Add User</button>
                </div>

                <!-- DATABASE SETUP -->
                <div class="admin-panel" style="background: linear-gradient(135deg, #d4edda 0%, #c3e6cb 100%); border: 3px solid #28a745;">
                    <h2>üóÑÔ∏è Database Setup</h2>
                    <p style="color: #155724; margin-bottom: 1rem; font-weight: 600;">
                        ‚úÖ Postgres database connected! Initialize to create tables and enable cross-browser sync.
                    </p>

                    <div style="display: flex; gap: 1rem; flex-wrap: wrap; margin-bottom: 1rem;">
                        <button class="btn-success" onclick="initializeDatabase()" style="flex: 1; min-width: 200px;">
                            üîÑ Initialize Database
                        </button>
                        <button class="btn-primary" onclick="syncToDatabase()" style="flex: 1; min-width: 200px;">
                            ‚òÅÔ∏è Sync LocalStorage to Database
                        </button>
                    </div>

                    <div style="background: white; padding: 1rem; border-radius: 8px;">
                        <p style="font-size: 0.9rem; color: var(--text-dark);">
                            <strong>Note:</strong> After initialization, all data will be stored in Postgres and work across all browsers and devices!
                        </p>
                    </div>
                </div>

                <!-- DUPLICATE PHONE CHECK -->
                <div class="admin-panel" id="duplicatePhonePanel" style="background: linear-gradient(135deg, #f8d7da 0%, #f5c6cb 100%); border: 3px solid #dc3545; display: none;">
                    <h2>‚ö†Ô∏è Duplicate Phone Numbers</h2>
                    <p style="color: #721c24; margin-bottom: 1rem; font-weight: 600;">
                        The following phone numbers are registered to multiple users. Please resolve these duplicates.
                    </p>
                    <div id="duplicatePhonesList"></div>
                </div>

                <!-- DATA BACKUP & RESTORE -->
                <div class="admin-panel" style="background: linear-gradient(135deg, #fff3cd 0%, #ffe69c 100%); border: 3px solid #ff9800;">
                    <h2>üíæ Data Backup & Restore</h2>
                    <p style="color: #856404; margin-bottom: 1rem; font-weight: 600;">
                        ‚ö†Ô∏è IMPORTANT: Backup your data regularly to prevent data loss!
                    </p>

                    <div style="display: flex; gap: 1rem; flex-wrap: wrap; margin-bottom: 1rem;">
                        <button class="btn-success" onclick="exportAllData()" style="flex: 1; min-width: 200px;">
                            üì• Download Complete Backup
                        </button>
                        <button class="btn-primary" onclick="document.getElementById('importFileInput').click()" style="flex: 1; min-width: 200px;">
                            üì§ Restore from Backup
                        </button>
                        <button class="btn-danger" onclick="checkDuplicatePhones()" style="flex: 1; min-width: 200px;">
                            üîç Check Duplicate Phones
                        </button>
                    </div>

                    <input type="file" id="importFileInput" accept=".json" style="display: none;" onchange="importAllData(event)">

                    <div style="background: white; padding: 1rem; border-radius: 8px; margin-top: 1rem;">
                        <h4 style="margin-bottom: 0.5rem;">üìä Current Data:</h4>
                        <div id="dataStats" style="font-family: monospace; color: var(--text-dark);"></div>
                    </div>
                </div>

                <!-- Registered Users List -->
                <div class="admin-panel">
                    <h2>üë• Registered Users</h2>
                    <div class="table-container">
                        <div id="usersListContainer"></div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // ============================================
        // DATABASE CONFIGURATION
        // ============================================
        const USE_DATABASE = true; // Set to true to use Postgres, false for localStorage
        const API_URL = '/api/db';

        // Database Helper Functions
        async function dbCall(action, data = {}) {
            try {
                const url = `${API_URL}?action=${action}`;
                const options = {
                    method: data.method || 'POST',
                    headers: { 'Content-Type': 'application/json' }
                };

                if (data.method !== 'GET' && Object.keys(data).length > 0) {
                    options.body = JSON.stringify(data);
                }

                const response = await fetch(url, options);
                const result = await response.json();

                if (!response.ok) {
                    throw new Error(result.error || 'Database error');
                }

                return result;
            } catch (error) {
                console.error('Database call failed:', error);
                showMessage('Database error: ' + error.message, 'error');
                throw error;
            }
        }

        async function initializeDatabase() {
            if (!confirm('Initialize database? This will create all tables and set up the admin user.')) {
                return;
            }

            try {
                showMessage('Initializing database...', 'success');
                await dbCall('init');

                // Load default matches into database
                await loadDefaultMatchesToDB();

                showMessage('Database initialized successfully! Refreshing page...', 'success');
                setTimeout(() => location.reload(), 2000);
            } catch (error) {
                showMessage('Failed to initialize database: ' + error.message, 'error');
            }
        }

        async function loadDefaultMatchesToDB() {
            for (const fixture of GROUP_STAGE_FIXTURES) {
                const team1Obj = TEAMS.find(t => t.name === fixture.team1);
                const team2Obj = TEAMS.find(t => t.name === fixture.team2);

                if (!team1Obj || !team2Obj) continue;

                const matchDateTime = new Date(fixture.date + 'T' + fixture.time);
                const match = {
                    id: `fixture_${fixture.date}_${fixture.time}_${team1Obj.code}_${team2Obj.code}`,
                    team1: team1Obj,
                    team2: team2Obj,
                    dateTime: matchDateTime.toISOString(),
                    stage: 'group',
                    status: 'upcoming',
                    winner: null,
                    points: 1
                };

                try {
                    await dbCall('addMatch', { match });
                } catch (e) {
                    console.log('Match already exists or error:', e.message);
                }
            }
        }

        // Load shared data (predictions & stats) from database for all users
        // This ensures leaderboard and user prediction stats show data from all users
        async function loadSharedDataFromDatabase() {
            try {
                console.log('üì° Loading shared data from database...');

                // Load all predictions from database
                const dbPredictions = await dbCall('getPredictions', { method: 'GET' });

                // Convert database predictions to localStorage format
                // Database format: [{username, match_id, team, result}, ...]
                // localStorage format: {username: {matchId: {team, result}}, ...}
                const predictionsMap = {};
                for (const pred of dbPredictions) {
                    if (!predictionsMap[pred.username]) {
                        predictionsMap[pred.username] = {};
                    }
                    predictionsMap[pred.username][pred.match_id] = {
                        team: pred.team,
                        result: pred.result
                    };
                }

                // Merge: database is source of truth for results
                const existingPredictions = getLocalStorage('predictions', {});
                const mergedPredictions = { ...predictionsMap };

                // Only add local predictions that don't exist in DB yet (truly offline predictions)
                if (currentUser && existingPredictions[currentUser.username]) {
                    const localPreds = existingPredictions[currentUser.username];
                    const dbPreds = mergedPredictions[currentUser.username] || {};
                    for (const matchId in localPreds) {
                        if (!dbPreds[matchId]) {
                            // This prediction only exists locally ‚Äî keep it
                            if (!mergedPredictions[currentUser.username]) {
                                mergedPredictions[currentUser.username] = {};
                            }
                            mergedPredictions[currentUser.username][matchId] = localPreds[matchId];
                        }
                        // If prediction exists in DB, DB version wins (has correct result)
                    }
                }

                setLocalStorage('predictions', mergedPredictions);
                console.log(`‚úÖ Loaded predictions for ${Object.keys(predictionsMap).length} users`);

                // Calculate stats for ALL users who have predictions
                // This ensures everyone who made a prediction appears on the leaderboard
                const matches = getLocalStorage('matches', []);
                const calculatedStats = {};

                for (const username in mergedPredictions) {
                    const userPreds = mergedPredictions[username];
                    let total = 0;
                    let correct = 0;
                    let points = 0;

                    for (const matchId in userPreds) {
                        total++;
                        if (userPreds[matchId].result === 'correct') {
                            correct++;
                            const match = matches.find(m => m.id === matchId);
                            const matchPoints = match?.points || 1;
                            points += matchPoints;
                        }
                    }

                    calculatedStats[username] = {
                        username: username,
                        totalPredictions: total,
                        correctPredictions: correct,
                        points: points,
                        accuracy: total > 0 ? ((correct / total) * 100).toFixed(1) : 0
                    };
                }

                // Also load stats from database and merge (in case there are stats without predictions)
                try {
                    const dbStats = await dbCall('getStats', { method: 'GET' });
                    for (const stat of dbStats) {
                        if (!calculatedStats[stat.username]) {
                            calculatedStats[stat.username] = {
                                username: stat.username,
                                totalPredictions: stat.total_predictions || 0,
                                correctPredictions: stat.correct_predictions || 0,
                                points: stat.points || 0,
                                accuracy: stat.accuracy || 0
                            };
                        }
                    }
                } catch (e) {
                    console.log('Could not load stats from database:', e.message);
                }

                setLocalStorage('userStats', calculatedStats);
                console.log(`‚úÖ Calculated stats for ${Object.keys(calculatedStats).length} users`);

            } catch (error) {
                console.log('‚ö†Ô∏è Could not load shared data from database:', error.message);
                // Continue with local data if database is unavailable
            }
        }

        // ============================================
        // T20 World Cup 2026 Teams with Flags and Groups
        // ============================================
        // Flag image helper - uses flagcdn.com for reliable cross-device flag display
        function flagImg(countryCode, size = 40) {
            return `<img src="https://flagcdn.com/w80/${countryCode}.png" alt="${countryCode}" width="${size}" height="${Math.round(size * 0.75)}" style="border-radius:3px; box-shadow:0 1px 3px rgba(0,0,0,0.2);" onerror="this.style.display='none'; this.nextSibling.style.display='inline';">`;
        }

        const TEAMS = [
            // Group A
            { name: 'India', flag: flagImg('in'), code: 'IND', group: 'A', countryCode: 'in' },
            { name: 'Pakistan', flag: flagImg('pk'), code: 'PAK', group: 'A', countryCode: 'pk' },
            { name: 'Netherlands', flag: flagImg('nl'), code: 'NED', group: 'A', countryCode: 'nl' },
            { name: 'Namibia', flag: flagImg('na'), code: 'NAM', group: 'A', countryCode: 'na' },
            { name: 'USA', flag: flagImg('us'), code: 'USA', group: 'A', countryCode: 'us' },

            // Group B
            { name: 'Sri Lanka', flag: flagImg('lk'), code: 'SL', group: 'B', countryCode: 'lk' },
            { name: 'Australia', flag: flagImg('au'), code: 'AUS', group: 'B', countryCode: 'au' },
            { name: 'Zimbabwe', flag: flagImg('zw'), code: 'ZIM', group: 'B', countryCode: 'zw' },
            { name: 'Ireland', flag: flagImg('ie'), code: 'IRE', group: 'B', countryCode: 'ie' },
            { name: 'Oman', flag: flagImg('om'), code: 'OMA', group: 'B', countryCode: 'om' },

            // Group C
            { name: 'England', flag: flagImg('gb-eng'), code: 'ENG', group: 'C', countryCode: 'gb-eng' },
            { name: 'West Indies', flag: '<span style="font-size:inherit;">üèè</span>', code: 'WI', group: 'C', countryCode: 'wi' },
            { name: 'Scotland', flag: flagImg('gb-sct'), code: 'SCO', group: 'C', countryCode: 'gb-sct' },
            { name: 'Italy', flag: flagImg('it'), code: 'ITA', group: 'C', countryCode: 'it' },
            { name: 'Nepal', flag: flagImg('np'), code: 'NEP', group: 'C', countryCode: 'np' },

            // Group D
            { name: 'South Africa', flag: flagImg('za'), code: 'RSA', group: 'D', countryCode: 'za' },
            { name: 'New Zealand', flag: flagImg('nz'), code: 'NZL', group: 'D', countryCode: 'nz' },
            { name: 'Afghanistan', flag: flagImg('af'), code: 'AFG', group: 'D', countryCode: 'af' },
            { name: 'Canada', flag: flagImg('ca'), code: 'CAN', group: 'D', countryCode: 'ca' },
            { name: 'UAE', flag: flagImg('ae'), code: 'UAE', group: 'D', countryCode: 'ae' }
        ];

        // Helper to get the correct flag HTML for a team name (handles DB-stored emoji flags)
        // Map replaced teams so DB data with old names still renders correctly
        const TEAM_REPLACEMENTS = {
            'Bangladesh': 'Scotland'
        };

        function getTeamFlag(teamName) {
            const resolvedName = TEAM_REPLACEMENTS[teamName] || teamName;
            const team = TEAMS.find(t => t.name === resolvedName);
            return team ? team.flag : resolvedName;
        }

        function resolveTeamName(teamName) {
            return TEAM_REPLACEMENTS[teamName] || teamName;
        }

        const MATCH_STAGES = [
            { value: 'group', label: 'Group Stage' },
            { value: 'super8', label: 'Super 8' },
            { value: 'semi', label: 'Semi Final' },
            { value: 'final', label: 'Final' }
        ];

        // Default admin credentials and reset password
        const ADMIN_USERNAME = 'admin';
        const ADMIN_PASSWORD = 'admin123';
        const DEFAULT_RESET_PASSWORD = 'change123';

        // T20 World Cup 2026 Group Stage Fixtures (MVT Timings)
        const GROUP_STAGE_FIXTURES = [
            { date: '2026-02-07', time: '10:30', team1: 'Pakistan', team2: 'Netherlands' },
            { date: '2026-02-07', time: '14:30', team1: 'West Indies', team2: 'Scotland' },
            { date: '2026-02-07', time: '18:30', team1: 'India', team2: 'USA' },
            { date: '2026-02-08', time: '10:30', team1: 'New Zealand', team2: 'Afghanistan' },
            { date: '2026-02-08', time: '14:30', team1: 'England', team2: 'Nepal' },
            { date: '2026-02-08', time: '18:30', team1: 'Sri Lanka', team2: 'Ireland' },
            { date: '2026-02-09', time: '10:30', team1: 'Scotland', team2: 'Italy' },
            { date: '2026-02-09', time: '14:30', team1: 'Zimbabwe', team2: 'Oman' },
            { date: '2026-02-09', time: '18:30', team1: 'South Africa', team2: 'Canada' },
            { date: '2026-02-10', time: '10:30', team1: 'Netherlands', team2: 'Namibia' },
            { date: '2026-02-10', time: '14:30', team1: 'New Zealand', team2: 'UAE' },
            { date: '2026-02-10', time: '18:30', team1: 'Pakistan', team2: 'USA' },
            { date: '2026-02-11', time: '10:30', team1: 'South Africa', team2: 'Afghanistan' },
            { date: '2026-02-11', time: '14:30', team1: 'Australia', team2: 'Ireland' },
            { date: '2026-02-11', time: '18:30', team1: 'England', team2: 'West Indies' },
            { date: '2026-02-12', time: '10:30', team1: 'Sri Lanka', team2: 'Oman' },
            { date: '2026-02-12', time: '14:30', team1: 'Nepal', team2: 'Italy' },
            { date: '2026-02-12', time: '18:30', team1: 'India', team2: 'Namibia' },
            { date: '2026-02-13', time: '10:30', team1: 'Australia', team2: 'Zimbabwe' },
            { date: '2026-02-13', time: '14:30', team1: 'Canada', team2: 'UAE' },
            { date: '2026-02-13', time: '18:30', team1: 'USA', team2: 'Netherlands' },
            { date: '2026-02-14', time: '10:30', team1: 'Ireland', team2: 'Oman' },
            { date: '2026-02-14', time: '14:30', team1: 'England', team2: 'Scotland' },
            { date: '2026-02-14', time: '18:30', team1: 'New Zealand', team2: 'South Africa' },
            { date: '2026-02-15', time: '10:30', team1: 'West Indies', team2: 'Nepal' },
            { date: '2026-02-15', time: '14:30', team1: 'USA', team2: 'Namibia' },
            { date: '2026-02-15', time: '18:30', team1: 'India', team2: 'Pakistan' },
            { date: '2026-02-16', time: '10:30', team1: 'Afghanistan', team2: 'UAE' },
            { date: '2026-02-16', time: '14:30', team1: 'England', team2: 'Italy' },
            { date: '2026-02-16', time: '18:30', team1: 'Australia', team2: 'Sri Lanka' },
            { date: '2026-02-17', time: '10:30', team1: 'New Zealand', team2: 'Canada' },
            { date: '2026-02-17', time: '14:30', team1: 'Ireland', team2: 'Zimbabwe' },
            { date: '2026-02-17', time: '18:30', team1: 'Scotland', team2: 'Nepal' },
            { date: '2026-02-18', time: '10:30', team1: 'South Africa', team2: 'UAE' },
            { date: '2026-02-18', time: '14:30', team1: 'Pakistan', team2: 'Namibia' },
            { date: '2026-02-18', time: '18:30', team1: 'India', team2: 'Netherlands' },
            { date: '2026-02-19', time: '10:30', team1: 'West Indies', team2: 'Italy' },
            { date: '2026-02-19', time: '14:30', team1: 'Sri Lanka', team2: 'Zimbabwe' },
            { date: '2026-02-19', time: '18:30', team1: 'Afghanistan', team2: 'Canada' },
            { date: '2026-02-20', time: '18:30', team1: 'Australia', team2: 'Oman' }
        ];

        // Global state
        let currentUser = null;
        let isAdmin = false;
        let selectedTeam1 = null;
        let selectedTeam2 = null;

        // LocalStorage helpers
        function getLocalStorage(key, defaultValue = null) {
            try {
                const item = localStorage.getItem(key);
                return item ? JSON.parse(item) : defaultValue;
            } catch (error) {
                console.error('Error reading from localStorage:', error);
                return defaultValue;
            }
        }

        function setLocalStorage(key, value) {
            try {
                localStorage.setItem(key, JSON.stringify(value));
            } catch (error) {
                console.error('Error writing to localStorage:', error);
            }
        }

        // Initialize team dropdowns
        function initTeamDropdowns() {
            const team1Options = document.getElementById('team1Options');
            const team2Options = document.getElementById('team2Options');

            const optionsHTML = TEAMS.map(team => `
                <div class="team-option" onclick="selectTeam('team1', '${team.name}', '${team.flag}')">
                    <span class="team-option-flag">${team.flag}</span>
                    <span class="team-option-name">${team.name}</span>
                </div>
            `).join('');

            team1Options.innerHTML = optionsHTML;
            team2Options.innerHTML = optionsHTML.replace(/team1/g, 'team2');
        }

        function toggleTeamDropdown(teamId) {
            const dropdown = document.getElementById(teamId + 'Dropdown');
            const otherDropdown = teamId === 'team1' ? document.getElementById('team2Dropdown') : document.getElementById('team1Dropdown');

            otherDropdown.classList.remove('show');
            dropdown.classList.toggle('show');
        }

        function selectTeam(teamId, teamName, teamFlag) {
            if (teamId === 'team1') {
                selectedTeam1 = { name: teamName, flag: teamFlag };
                document.getElementById('team1Display').innerHTML = `${teamFlag} ${teamName}`;
            } else {
                selectedTeam2 = { name: teamName, flag: teamFlag };
                document.getElementById('team2Display').innerHTML = `${teamFlag} ${teamName}`;
            }
            document.getElementById(teamId + 'Dropdown').classList.remove('show');
        }

        function filterTeams(teamId, searchTerm) {
            const optionsDiv = document.getElementById(teamId + 'Options');
            const filteredTeams = TEAMS.filter(team =>
                team.name.toLowerCase().includes(searchTerm.toLowerCase())
            );

            const optionsHTML = filteredTeams.map(team => `
                <div class="team-option" onclick="selectTeam('${teamId}', '${team.name}', '${team.flag}')">
                    <span class="team-option-flag">${team.flag}</span>
                    <span class="team-option-name">${team.name}</span>
                </div>
            `).join('');

            optionsDiv.innerHTML = optionsHTML || '<div style="padding: 1rem; text-align: center; color: #999;">No teams found</div>';
        }

        // Close dropdowns when clicking outside
        document.addEventListener('click', function(event) {
            if (!event.target.closest('.team-select')) {
                document.querySelectorAll('.team-dropdown').forEach(dropdown => {
                    dropdown.classList.remove('show');
                });
            }
        });

        // Authentication

        // Initialize users database with admin
        function initializeUsers() {
            let users = getLocalStorage('users', []);

            // Create admin user if doesn't exist
            const adminExists = users.find(u => u.username === ADMIN_USERNAME);
            if (!adminExists) {
                users.push({
                    username: ADMIN_USERNAME,
                    password: ADMIN_PASSWORD,
                    role: 'admin',
                    needsPasswordChange: false
                });
                setLocalStorage('users', users);
            }
        }

        // Login function
        async function login() {
            const username = document.getElementById('loginUsername').value.trim();
            const password = document.getElementById('loginPassword').value;

            if (!username || !password) {
                showError('Please enter both username and password.', 'loginError');
                return;
            }

            try {
                // Try database first if enabled
                if (USE_DATABASE) {
                    const dbUsers = await dbCall('getUsers');
                    const user = dbUsers.find(u => u.username === username);

                    if (user && user.password === password) {
                        // Save to localStorage for offline access
                        let localUsers = getLocalStorage('users', []);
                        const existingIndex = localUsers.findIndex(u => u.username === username);
                        if (existingIndex >= 0) {
                            localUsers[existingIndex] = {
                                username: user.username,
                                phone: user.phone,
                                password: user.password,
                                role: user.role,
                                needsPasswordChange: user.needs_reset
                            };
                        } else {
                            localUsers.push({
                                username: user.username,
                                phone: user.phone,
                                password: user.password,
                                role: user.role,
                                needsPasswordChange: user.needs_reset
                            });
                        }
                        setLocalStorage('users', localUsers);

                        proceedWithLogin(user, password);
                        return;
                    }
                }
            } catch (error) {
                console.log('Database login failed, trying localStorage:', error);
            }

            // Fallback to localStorage
            const users = getLocalStorage('users', []);
            const user = users.find(u => u.username === username);

            if (!user) {
                showError('Invalid username or password!', 'loginError');
                return;
            }

            if (user.password !== password) {
                showError('Invalid username or password!', 'loginError');
                return;
            }

            proceedWithLogin(user, password);
        }

        function proceedWithLogin(user, password) {

            // Check if user needs to change password
            if (user.needsPasswordChange) {
                alert(`Your password has been reset. Please use this password to login: ${DEFAULT_RESET_PASSWORD}\n\nYou'll be prompted to change it after login.`);
                if (password !== DEFAULT_RESET_PASSWORD) {
                    showError('Please use the default password provided.', 'loginError');
                    return;
                }

                // Prompt for new password
                const newPassword = prompt('Please enter a new password:');
                if (!newPassword || newPassword.length < 4) {
                    showError('Password must be at least 4 characters.', 'loginError');
                    return;
                }

                // Update password
                user.password = newPassword;
                user.needsPasswordChange = false;
                const userIndex = users.findIndex(u => u.username === username);
                users[userIndex] = user;
                setLocalStorage('users', users);
            }

            currentUser = { username: user.username, role: user.role };
            isAdmin = user.role === 'admin';
            setLocalStorage('currentUser', currentUser);
            setLocalStorage('isAdmin', isAdmin);

            initializeApp();
        }

        // Register function
        async function register() {
            const username = document.getElementById('registerUsername').value.trim();
            const phone = document.getElementById('registerPhone').value.trim();
            const password = document.getElementById('registerPassword').value;
            const confirmPassword = document.getElementById('registerConfirmPassword').value;

            if (!username || username.length < 3) {
                showError('Username must be at least 3 characters.', 'registerError');
                return;
            }

            if (!phone || phone.length !== 7 || !/^[0-9]{7}$/.test(phone)) {
                showError('Contact number must be exactly 7 digits.', 'registerError');
                return;
            }

            if (!password || password.length < 4) {
                showError('Password must be at least 4 characters.', 'registerError');
                return;
            }

            if (password !== confirmPassword) {
                showError('Passwords do not match!', 'registerError');
                return;
            }

            // Check if user exists in database first
            try {
                if (USE_DATABASE) {
                    const dbUsers = await dbCall('getUsers');

                    // Check if username already exists in database
                    if (dbUsers.find(u => u.username === username)) {
                        showError('Username already exists!', 'registerError');
                        return;
                    }

                    // Check if phone number already exists in database
                    if (dbUsers.find(u => u.phone === phone)) {
                        showError('This contact number is already registered!', 'registerError');
                        return;
                    }

                    // Add user to database
                    await dbCall('addUser', {
                        username: username,
                        phone: phone,
                        password: password,
                        role: 'user',
                        needsReset: false
                    });

                    // Also save to localStorage for offline access
                    const users = getLocalStorage('users', []);
                    users.push({
                        username: username,
                        phone: phone,
                        password: password,
                        role: 'user',
                        needsPasswordChange: false
                    });
                    setLocalStorage('users', users);

                    alert('Registration successful! You can now login from any browser.');
                    showLoginPage();
                    return;
                }
            } catch (error) {
                console.log('Database registration failed, using localStorage:', error);
            }

            // Fallback to localStorage only
            const users = getLocalStorage('users', []);

            // Check if username already exists
            if (users.find(u => u.username === username)) {
                showError('Username already exists!', 'registerError');
                return;
            }

            // Check if phone number already exists
            if (users.find(u => u.phone === phone)) {
                showError('This contact number is already registered!', 'registerError');
                return;
            }

            // Add new user
            users.push({
                username: username,
                phone: phone,
                password: password,
                role: 'user',
                needsPasswordChange: false
            });
            setLocalStorage('users', users);

            alert('Registration successful! You can now login.');
            showLoginPage();
        }

        // Logout function
        function logout() {
            if (confirm('Are you sure you want to logout?')) {
                localStorage.removeItem('currentUser');
                localStorage.removeItem('isAdmin');
                currentUser = null;
                isAdmin = false;

                document.getElementById('mainApp').classList.add('hidden');
                document.getElementById('loginPage').classList.remove('hidden');
                document.getElementById('loginUsername').value = '';
                document.getElementById('loginPassword').value = '';
            }
        }

        // Page navigation functions
        function showLoginPage() {
            document.getElementById('loginPage').classList.remove('hidden');
            document.getElementById('registerPage').classList.add('hidden');
            document.getElementById('loginError').classList.add('hidden');
            document.getElementById('registerError').classList.add('hidden');
        }

        function showRegisterPage() {
            document.getElementById('loginPage').classList.add('hidden');
            document.getElementById('registerPage').classList.remove('hidden');
            document.getElementById('loginError').classList.add('hidden');
            document.getElementById('registerError').classList.add('hidden');
        }

        // User Management Functions (Admin only)
        async function addUser() {
            const username = document.getElementById('newUserUsername').value.trim();
            const phone = document.getElementById('newUserPhone').value.trim();
            const password = document.getElementById('newUserPassword').value;

            if (!username || username.length < 3) {
                alert('Username must be at least 3 characters.');
                return;
            }

            if (!phone || phone.length !== 7 || !/^[0-9]{7}$/.test(phone)) {
                alert('Contact number must be exactly 7 digits.');
                return;
            }

            if (!password || password.length < 4) {
                alert('Password must be at least 4 characters.');
                return;
            }

            try {
                if (USE_DATABASE) {
                    const dbUsers = await dbCall('getUsers');

                    if (dbUsers.find(u => u.username === username)) {
                        alert('Username already exists!');
                        return;
                    }

                    if (dbUsers.find(u => u.phone === phone)) {
                        alert('This contact number is already registered!');
                        return;
                    }

                    await dbCall('addUser', {
                        username: username,
                        phone: phone,
                        password: password,
                        role: 'user',
                        needsReset: false
                    });
                }
            } catch (error) {
                console.log('Database addUser failed, using localStorage:', error);
            }

            // Also save to localStorage
            const users = getLocalStorage('users', []);
            if (!users.find(u => u.username === username)) {
                users.push({
                    username: username,
                    phone: phone,
                    password: password,
                    role: 'user',
                    needsPasswordChange: false
                });
                setLocalStorage('users', users);
            }

            document.getElementById('newUserUsername').value = '';
            document.getElementById('newUserPhone').value = '';
            document.getElementById('newUserPassword').value = '';

            alert('User added successfully!');
            renderUsersList();
        }

        async function resetUserPassword(username) {
            if (!confirm(`Reset password for user: ${username}?\n\nThe user will need to change their password on next login.`)) {
                return;
            }

            try {
                if (USE_DATABASE) {
                    await dbCall('updateUser', {
                        username: username,
                        password: DEFAULT_RESET_PASSWORD,
                        needsReset: true
                    });
                }
            } catch (error) {
                console.log('Database resetUserPassword failed:', error);
            }

            const users = getLocalStorage('users', []);
            const userIndex = users.findIndex(u => u.username === username);

            if (userIndex !== -1) {
                users[userIndex].password = DEFAULT_RESET_PASSWORD;
                users[userIndex].needsPasswordChange = true;
                setLocalStorage('users', users);
            }

            alert(`Password reset successfully!\n\nDefault password: ${DEFAULT_RESET_PASSWORD}\n\nUser will be prompted to change it on next login.`);
            renderUsersList();
        }

        async function deleteUser(username) {
            if (username === ADMIN_USERNAME) {
                alert('Cannot delete admin user!');
                return;
            }

            if (!confirm(`Delete user: ${username}?\n\nThis action cannot be undone. This will also delete all predictions and stats for this user.`)) {
                return;
            }

            try {
                if (USE_DATABASE) {
                    await dbCall('deleteUser', { username: username });
                }
            } catch (error) {
                console.log('Database deleteUser failed:', error);
            }

            // Remove user from users list
            let users = getLocalStorage('users', []);
            users = users.filter(u => u.username !== username);
            setLocalStorage('users', users);

            // Remove user's predictions
            let predictions = getLocalStorage('predictions', {});
            delete predictions[username];
            setLocalStorage('predictions', predictions);

            // Remove user's stats
            let userStats = getLocalStorage('userStats', {});
            delete userStats[username];
            setLocalStorage('userStats', userStats);

            // Force recalculate all stats to ensure consistency
            updateAllUserStats();

            alert('User deleted successfully!');
            renderUsersList();
            updateLeaderboard();
        }

        async function renderUsersList() {
            let users = getLocalStorage('users', []);

            // Fetch from database to get users created on other devices
            if (USE_DATABASE) {
                try {
                    const dbUsers = await dbCall('getUsers');
                    if (dbUsers && dbUsers.length > 0) {
                        // Update localStorage with database users
                        users = dbUsers.map(u => ({
                            username: u.username,
                            phone: u.phone,
                            password: u.password,
                            role: u.role,
                            needsPasswordChange: u.needs_reset
                        }));
                        setLocalStorage('users', users);
                    }
                } catch (error) {
                    console.log('Failed to fetch users from database, using localStorage:', error);
                }
            }
            const container = document.getElementById('usersListContainer');

            if (users.length === 0) {
                container.innerHTML = '<p style="text-align: center; color: var(--text-gray); padding: 2rem;">No users registered yet.</p>';
                return;
            }

            container.innerHTML = `
                <table class="users-table">
                    <thead>
                        <tr>
                            <th>Username</th>
                            <th>Contact</th>
                            <th>Role</th>
                            <th>Status</th>
                            <th>Actions</th>
                        </tr>
                    </thead>
                    <tbody>
                        ${users.map(user => `
                            <tr>
                                <td><strong>${user.username}</strong></td>
                                <td>${user.phone ? '+960 ' + user.phone : '-'}</td>
                                <td>
                                    <span class="user-badge ${user.role}">
                                        ${user.role === 'admin' ? 'üëë ADMIN' : 'üë§ USER'}
                                    </span>
                                </td>
                                <td>
                                    ${user.needsPasswordChange ?
                                        '<span class="user-badge pending-reset">üîÑ Pending Reset</span>' :
                                        '<span style="color: var(--success-green);">‚úÖ Active</span>'
                                    }
                                </td>
                                <td>
                                    ${user.username !== ADMIN_USERNAME ? `
                                        <button class="btn-reset" onclick="resetUserPassword('${user.username}')">
                                            üîê Reset Password
                                        </button>
                                        <button class="btn-delete-user" onclick="deleteUser('${user.username}')">
                                            üóëÔ∏è Delete
                                        </button>
                                    ` : '<em style="color: var(--text-gray);">Protected</em>'}
                                </td>
                            </tr>
                        `).join('')}
                    </tbody>
                </table>
            `;
        }

        async function initializeApp() {
            document.getElementById('loginPage').classList.add('hidden');
            document.getElementById('registerPage').classList.add('hidden');
            document.getElementById('mainApp').classList.remove('hidden');
            document.getElementById('userDisplay').textContent = currentUser.username;

            if (isAdmin) {
                document.getElementById('adminBadge').classList.remove('hidden');
                document.getElementById('adminTabBtn').classList.remove('hidden');
                document.getElementById('usersTabBtn').classList.remove('hidden');
                initTeamDropdowns();
            } else {
                document.getElementById('adminBadge').classList.add('hidden');
                document.getElementById('adminTabBtn').classList.add('hidden');
                document.getElementById('usersTabBtn').classList.add('hidden');
            }

            // Always show Match Predictions tab on login
            document.getElementById('predictionsTab').classList.remove('hidden');
            document.getElementById('leaderboardTab').classList.add('hidden');
            document.getElementById('adminTab').classList.add('hidden');
            document.getElementById('usersTab').classList.add('hidden');

            // Set Match Predictions tab as active
            document.querySelectorAll('.tab-btn').forEach(btn => btn.classList.remove('active'));
            document.querySelectorAll('.tab-btn')[0].classList.add('active'); // First tab is Match Predictions

            // Show/hide "How It Works" box based on user preference
            const howItWorksClosed = getLocalStorage('howItWorksClosed', false);
            const howItWorksBox = document.getElementById('howItWorksBox');
            if (howItWorksClosed) {
                howItWorksBox.style.display = 'none';
            } else {
                howItWorksBox.style.display = 'block';
            }

            // Sync current user's local predictions to database (for users who predicted before sync was added)
            await syncCurrentUserPredictionsToDatabase();

            // Load shared data from database for leaderboard and prediction stats
            await loadSharedDataFromDatabase();

            renderMatches();
            updateLeaderboard();

            // Check and send Telegram reminders for upcoming matches
            checkPredictionReminders();
            // Re-check every 5 minutes while app is open
            setInterval(checkPredictionReminders, 5 * 60 * 1000);
        }

        // Silently check if any upcoming matches need a Telegram reminder
        async function checkPredictionReminders() {
            if (!USE_DATABASE) return;
            try {
                await fetch(`${API_URL}?action=checkAndSendReminders`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({})
                });
            } catch (e) {
                // Silent fail - reminders are best-effort
            }
        }

        // Sync current user's predictions from localStorage to database
        // This ensures predictions made before database sync was added get uploaded
        async function syncCurrentUserPredictionsToDatabase() {
            if (!currentUser || isAdmin) return;

            const predictions = getLocalStorage('predictions', {});
            const userPredictions = predictions[currentUser.username];

            if (!userPredictions || Object.keys(userPredictions).length === 0) {
                console.log('No local predictions to sync for', currentUser.username);
                return;
            }

            console.log(`üì§ Syncing ${Object.keys(userPredictions).length} predictions for ${currentUser.username} to database...`);

            for (const matchId in userPredictions) {
                const pred = userPredictions[matchId];
                try {
                    // Only sync the team choice, NEVER the result
                    // Results are set server-side by updateMatchResults
                    await dbCall('savePrediction', {
                        username: currentUser.username,
                        matchId: matchId,
                        team: pred.team
                    });
                } catch (e) {
                    console.log('Could not sync prediction:', e.message);
                }
            }

            // Also sync user stats
            const stats = getLocalStorage('userStats', {});
            const userStat = stats[currentUser.username];
            if (userStat) {
                try {
                    await dbCall('updateStats', { stats: [userStat] });
                } catch (e) {
                    console.log('Could not sync stats:', e.message);
                }
            }

            console.log(`‚úÖ Synced predictions for ${currentUser.username}`);
        }

        // How It Works functions
        function closeHowItWorks() {
            document.getElementById('howItWorksBox').style.display = 'none';
            setLocalStorage('howItWorksClosed', true);
        }

        function showHowItWorks() {
            document.getElementById('howItWorksBox').style.display = 'block';
            setLocalStorage('howItWorksClosed', false);
        }

        // Tab Navigation
        function switchTab(tabName) {
            const tabs = ['predictionsTab', 'leaderboardTab', 'adminTab', 'usersTab'];
            tabs.forEach(tab => document.getElementById(tab).classList.add('hidden'));

            document.querySelectorAll('.tab-btn').forEach(btn => btn.classList.remove('active'));
            event.target.classList.add('active');

            document.getElementById(tabName + 'Tab').classList.remove('hidden');

            if (tabName === 'leaderboard') {
                updateLeaderboard();
            } else if (tabName === 'admin' && isAdmin) {
                renderAdminMatches();
            } else if (tabName === 'users' && isAdmin) {
                renderUsersList();
            } else if (tabName === 'predictions') {
                renderMatches();
            }
        }

        // Load pre-defined group stage fixtures
        function loadGroupStageFixtures() {
            const existingMatches = getLocalStorage('matches', []);

            // Check if fixtures are already loaded
            const fixturesLoaded = getLocalStorage('fixturesLoaded', false);
            if (fixturesLoaded) {
                console.log('‚úÖ Group stage fixtures already loaded');
                return;
            }

            console.log('üì¶ Loading 40 group stage fixtures...');

            GROUP_STAGE_FIXTURES.forEach(fixture => {
                // Find team objects
                const team1Obj = TEAMS.find(t => t.name === fixture.team1);
                const team2Obj = TEAMS.find(t => t.name === fixture.team2);

                if (!team1Obj || !team2Obj) {
                    console.error(`‚ùå Team not found: ${fixture.team1} vs ${fixture.team2}`);
                    return;
                }

                // Create match object
                const matchDateTime = new Date(fixture.date + 'T' + fixture.time);
                const newMatch = {
                    id: `fixture_${fixture.date}_${fixture.time}_${team1Obj.code}_${team2Obj.code}`,
                    team1: team1Obj,
                    team2: team2Obj,
                    dateTime: matchDateTime.toISOString(),
                    stage: 'group',
                    status: 'upcoming',
                    winner: null,
                    points: 1 // Default points for match
                };

                existingMatches.push(newMatch);
            });

            // Save all matches
            setLocalStorage('matches', existingMatches);
            setLocalStorage('fixturesLoaded', true);

            console.log(`‚úÖ Successfully loaded ${GROUP_STAGE_FIXTURES.length} group stage fixtures`);
        }

        // Match Management (Admin)
        function addMatch() {
            if (!selectedTeam1 || !selectedTeam2) {
                showMessage('Please select both teams!', 'error');
                return;
            }

            if (selectedTeam1.name === selectedTeam2.name) {
                showMessage('Teams must be different!', 'error');
                return;
            }

            const date = document.getElementById('matchDate').value;
            const time = document.getElementById('matchTime').value;
            const stage = document.getElementById('matchStage').value;

            if (!date || !time) {
                showMessage('Please fill all fields!', 'error');
                return;
            }

            const matches = getLocalStorage('matches', []);
            const matchDateTime = new Date(date + 'T' + time);

            const newMatch = {
                id: Date.now().toString(),
                team1: selectedTeam1,
                team2: selectedTeam2,
                dateTime: matchDateTime.toISOString(),
                stage: stage,
                status: 'upcoming',
                winner: null,
                points: 1 // Default points
            };

            matches.push(newMatch);
            setLocalStorage('matches', matches);

            showMessage('Match added successfully!', 'success');

            // Reset form
            selectedTeam1 = null;
            selectedTeam2 = null;
            document.getElementById('team1Display').innerHTML = 'Select Team 1';
            document.getElementById('team2Display').innerHTML = 'Select Team 2';
            document.getElementById('matchDate').value = '';
            document.getElementById('matchTime').value = '';
            document.getElementById('matchStage').value = 'group';

            renderAdminMatches();
            renderMatches();
        }

        async function deleteMatch(matchId) {
            if (!confirm('Are you sure you want to delete this match?')) return;

            // Delete from database
            if (USE_DATABASE) {
                try {
                    await dbCall('deleteMatch', { matchId: matchId });
                } catch (error) {
                    console.log('Failed to delete match from database:', error);
                }
            }

            let matches = getLocalStorage('matches', []);
            matches = matches.filter(m => m.id !== matchId);
            setLocalStorage('matches', matches);

            showMessage('Match deleted!', 'success');
            renderAdminMatches();
            renderMatches();
        }

        async function setMatchResult(matchId, winnerTeamName) {
            const matches = getLocalStorage('matches', []);
            const match = matches.find(m => m.id === matchId);

            if (match) {
                match.status = 'completed';
                match.winner = winnerTeamName;
                setLocalStorage('matches', matches);

                // Update database
                if (USE_DATABASE) {
                    try {
                        await dbCall('updateMatch', {
                            matchId: matchId,
                            status: 'completed',
                            winner: winnerTeamName,
                            points: match.points || 1
                        });
                    } catch (error) {
                        console.log('Failed to update match in database:', error);
                    }
                }

                // Update all predictions for this match
                await updatePredictionResults(matchId, winnerTeamName);

                // Send Telegram notification (fire-and-forget)
                if (USE_DATABASE) {
                    try {
                        const stats = getLocalStorage('userStats', {});
                        const leaderboardTop = Object.values(stats)
                            .filter(u => u.username !== 'admin')
                            .sort((a, b) => b.points - a.points || b.correctPredictions - a.correctPredictions)
                            .slice(0, 3)
                            .map(u => ({ username: u.username, points: u.points || 0 }));

                        dbCall('sendTelegram', {
                            matchDetails: {
                                team1: match.team1.name,
                                team1Flag: getTeamCode(match.team1.name),
                                team2: match.team2.name,
                                team2Flag: getTeamCode(match.team2.name),
                                winner: winnerTeamName
                            },
                            leaderboardTop
                        });
                    } catch (e) {
                        console.log('Telegram notification failed:', e.message);
                    }
                }

                showMessage('Result saved!', 'success');
                renderAdminMatches();
                renderMatches();
            }
        }

        // === Telegram Live Update Functions ===

        async function sendTelegramText(text) {
            if (!USE_DATABASE) return;
            try {
                await dbCall('sendTelegramUpdate', { text });
                showMessage('Sent to Telegram!', 'success');
            } catch (e) {
                showMessage('Failed to send to Telegram', 'error');
            }
        }

        function getMatchById(matchId) {
            const matches = getLocalStorage('matches', []);
            return matches.find(m => m.id === matchId);
        }

        // Get clean team code for Telegram (no HTML)
        function getTeamCode(teamName) {
            const resolvedName = TEAM_REPLACEMENTS[teamName] || teamName;
            const team = TEAMS.find(t => t.name === resolvedName);
            return team ? team.code : teamName;
        }

        function sendMatchUpdate(matchId, type) {
            const match = getMatchById(matchId);
            if (!match) return;

            const t1 = match.team1.name;
            const t2 = match.team2.name;
            const c1 = getTeamCode(t1);
            const c2 = getTeamCode(t2);
            const header = `*${t1}* (${c1}) vs *${t2}* (${c2})`;

            switch (type) {
                case 'start': {
                    if (confirm(`Send "Match Started" for ${t1} vs ${t2}?`)) {
                        sendTelegramText(`üèè *Match Started!*\n\n${header}\n\nüî¥ The match is now LIVE!`);
                    }
                    break;
                }
                case 'toss': {
                    const winner = prompt(`Who won the toss?\n\n1) ${t1}\n2) ${t2}\n\nEnter 1 or 2:`);
                    if (!winner || (winner !== '1' && winner !== '2')) return;
                    const tossWinner = winner === '1' ? t1 : t2;
                    const elected = prompt('Elected to?\n\n1) Bat\n2) Bowl\n\nEnter 1 or 2:');
                    if (!elected || (elected !== '1' && elected !== '2')) return;
                    const decision = elected === '1' ? 'BAT' : 'BOWL';
                    sendTelegramText(`ü™ô *Toss Result!*\n\n${header}\n\n*${tossWinner}* won the toss and elected to *${decision}*`);
                    break;
                }
                case 'wicket': {
                    const team = prompt(`Which team lost a wicket?\n\n1) ${t1}\n2) ${t2}\n\nEnter 1 or 2:`);
                    if (!team || (team !== '1' && team !== '2')) return;
                    const wTeam = team === '1' ? t1 : t2;
                    const runs = prompt('Runs:');
                    if (!runs) return;
                    const wickets = prompt('Wickets:');
                    if (!wickets) return;
                    const overs = prompt('Overs (e.g. 6.4):');
                    if (!overs) return;
                    sendTelegramText(`üí• *Wicket down for ${wTeam}!*\n\n${header}\n\n${wTeam}: *${runs}/${wickets}* in ${overs} overs`);
                    break;
                }
                case 'fifty': {
                    const fTeam = prompt(`Which team does the player belong to?\n\n1) ${t1}\n2) ${t2}\n\nEnter 1 or 2:`);
                    if (!fTeam || (fTeam !== '1' && fTeam !== '2')) return;
                    const playerTeam = fTeam === '1' ? t1 : t2;
                    const player = prompt('Player name:');
                    if (!player) return;
                    const milestone = prompt('Milestone?\n\n1) Fifty (50)\n2) Hundred (100)\n\nEnter 1 or 2:');
                    if (!milestone || (milestone !== '1' && milestone !== '2')) return;
                    const isHundred = milestone === '2';
                    const emoji = isHundred ? 'üíØ' : 'üî•';
                    const label = isHundred ? 'HUNDRED' : 'FIFTY';
                    sendTelegramText(`${emoji} *${label}!*\n\n${header}\n\nüèè *${player}* (${playerTeam}) reaches ${isHundred ? '100' : '50'}! ${emoji}`);
                    break;
                }
                case 'innings': {
                    const iTeam = prompt(`Which team's innings ended?\n\n1) ${t1}\n2) ${t2}\n\nEnter 1 or 2:`);
                    if (!iTeam || (iTeam !== '1' && iTeam !== '2')) return;
                    const inningsTeam = iTeam === '1' ? t1 : t2;
                    const iRuns = prompt('Final runs:');
                    if (!iRuns) return;
                    const iWickets = prompt('Wickets fallen:');
                    if (!iWickets) return;
                    const iOvers = prompt('Overs (e.g. 20):');
                    if (!iOvers) return;
                    sendTelegramText(`üìä *Innings Over!*\n\n${header}\n\n${inningsTeam}: *${iRuns}/${iWickets}* (${iOvers} overs)`);
                    break;
                }
            }
        }

        function pushLinkToTelegram() {
            const input = document.getElementById('pushLinkInput');
            const link = input.value.trim();
            if (!link) {
                showMessage('Please paste a link first!', 'error');
                return;
            }
            sendTelegramText(`üîó *Follow the match live!*\n\nüëâ ${link}`);
            input.value = '';
        }

        function pushCustomMessage() {
            const msg = prompt('Enter your custom message for the Telegram group:');
            if (!msg) return;
            sendTelegramText(`üì£ *Update:*\n\n${msg}`);
        }

        async function resetMatchResult(matchId) {
            if (!confirm('Reset this match result? This will revert it to upcoming status and recalculate all user points.')) {
                return;
            }

            const matches = getLocalStorage('matches', []);
            const match = matches.find(m => m.id === matchId);

            if (match) {
                const previousWinner = match.winner;

                // Reset match status
                match.status = 'upcoming';
                match.winner = null;
                setLocalStorage('matches', matches);

                // Update database
                if (USE_DATABASE) {
                    try {
                        await dbCall('updateMatch', {
                            matchId: matchId,
                            status: 'upcoming',
                            winner: null,
                            points: match.points || 1
                        });
                    } catch (error) {
                        console.log('Failed to reset match in database:', error);
                    }
                }

                // Revert all predictions for this match
                revertPredictionResults(matchId, previousWinner);

                showMessage('Match result reset successfully!', 'success');
                renderAdminMatches();
                renderMatches();
                updateLeaderboard();
            }
        }

        async function setMatchPoints(matchId, points) {
            const matches = getLocalStorage('matches', []);
            const match = matches.find(m => m.id === matchId);

            if (match) {
                match.points = points;
                setLocalStorage('matches', matches);

                // Update database
                if (USE_DATABASE) {
                    try {
                        await dbCall('updateMatch', {
                            matchId: matchId,
                            status: match.status || 'upcoming',
                            winner: match.winner || null,
                            points: points
                        });
                    } catch (error) {
                        console.log('Failed to update match points in database:', error);
                    }
                }

                // Recalculate all user stats with new points
                updateAllUserStats();

                showMessage(`Match points updated to ${points}!`, 'success');
                renderAdminMatches();
                renderMatches();
                updateLeaderboard();
            }
        }

        async function revertPredictionResults(matchId, previousWinner) {
            // Server-side batch revert: resets ALL predictions for this match
            // and recalculates ALL user stats in a single reliable operation
            if (USE_DATABASE) {
                try {
                    await dbCall('revertMatchResults', { matchId });
                    await loadSharedDataFromDatabase();
                    return;
                } catch (e) {
                    console.log('Server-side revert failed, falling back to client-side:', e.message);
                }
            }

            // Fallback: client-side revert
            let predictions = getLocalStorage('predictions', {});
            for (let username in predictions) {
                if (predictions[username][matchId]) {
                    predictions[username][matchId].result = null;
                }
            }
            setLocalStorage('predictions', predictions);
            await updateAllUserStats();
        }

        async function updatePredictionResults(matchId, winner) {
            // Server-side batch update: marks ALL predictions for this match
            // and recalculates ALL user stats in a single reliable operation
            if (USE_DATABASE) {
                try {
                    await dbCall('updateMatchResults', { matchId, winner });
                    // Refresh local data from database
                    await loadSharedDataFromDatabase();
                    return;
                } catch (e) {
                    console.log('Server-side update failed, falling back to client-side:', e.message);
                }
            }

            // Fallback: client-side update (only if server-side fails)
            let predictions = getLocalStorage('predictions', {});
            for (let username in predictions) {
                if (predictions[username][matchId]) {
                    const prediction = predictions[username][matchId];
                    prediction.result = (prediction.team === winner) ? 'correct' : 'incorrect';
                }
            }
            setLocalStorage('predictions', predictions);
            await updateAllUserStats();
        }

        async function renderAdminMatches() {
            let matches = getLocalStorage('matches', []);
            const container = document.getElementById('adminMatchesList');

            // Fetch matches from database for cross-device sync
            if (USE_DATABASE) {
                try {
                    const dbMatches = await dbCall('getMatches');
                    if (dbMatches && dbMatches.length > 0) {
                        matches = dbMatches.map(m => ({
                            id: m.id,
                            team1: { name: resolveTeamName(m.team1_name), flag: m.team1_flag, code: m.team1_code, group: m.team1_group },
                            team2: { name: resolveTeamName(m.team2_name), flag: m.team2_flag, code: m.team2_code, group: m.team2_group },
                            dateTime: m.date_time,
                            stage: m.stage,
                            status: m.status,
                            winner: m.winner,
                            points: m.points
                        }));
                        setLocalStorage('matches', matches);
                    }
                } catch (error) {
                    console.log('Failed to fetch matches from database, using localStorage:', error);
                }
            }

            if (matches.length === 0) {
                container.innerHTML = '<div class="empty-state"><p>No matches scheduled yet</p></div>';
                return;
            }

            container.innerHTML = matches.map(match => `
                <div class="admin-match-card">
                    <div class="admin-match-info">
                        <div class="admin-match-teams">
                            ${getTeamFlag(match.team1.name)} ${match.team1.name} vs ${getTeamFlag(match.team2.name)} ${match.team2.name}
                        </div>
                        <div class="admin-match-details">
                            ${getStageLabel(match.stage)} | üìÖ ${formatDateTime(match.dateTime)} |
                            Status: ${match.status === 'completed' ? '‚úÖ Completed' : '‚è≥ Upcoming'}
                            ${match.winner ? ` | Winner: ${match.winner}` : ''}
                        </div>
                        <div class="result-selector" style="background: linear-gradient(135deg, #fff3cd 0%, #ffe69c 100%); border: 2px solid #ffa500;">
                            <strong>‚≠ê Match Points:</strong>
                            <div class="result-buttons">
                                ${[1, 2, 3, 4, 5].map(pts => `
                                    <button class="result-btn ${(match.points || 1) === pts ? 'selected' : ''}"
                                            onclick="setMatchPoints('${match.id}', ${pts})"
                                            style="font-weight: 700;">
                                        ${pts} ${pts === 1 ? 'Point' : 'Points'}
                                    </button>
                                `).join('')}
                            </div>
                        </div>
                        ${match.status === 'upcoming' ? `
                            <div class="result-selector">
                                <strong>Set Winner:</strong>
                                <div class="result-buttons">
                                    <button class="result-btn" onclick="setMatchResult('${match.id}', '${match.team1.name}')">
                                        ${getTeamFlag(match.team1.name)} ${match.team1.name}
                                    </button>
                                    <button class="result-btn" onclick="setMatchResult('${match.id}', '${match.team2.name}')">
                                        ${getTeamFlag(match.team2.name)} ${match.team2.name}
                                    </button>
                                </div>
                            </div>
                        ` : ''}
                        <div class="tg-update-section">
                            <strong>üì¢ Telegram Updates:</strong>
                            <div class="tg-update-buttons">
                                <button class="tg-btn" onclick="sendMatchUpdate('${match.id}', 'start')">üèè Started</button>
                                <button class="tg-btn" onclick="sendMatchUpdate('${match.id}', 'toss')">ü™ô Toss</button>
                                <button class="tg-btn" onclick="sendMatchUpdate('${match.id}', 'wicket')">üí• Wicket</button>
                                <button class="tg-btn" onclick="sendMatchUpdate('${match.id}', 'fifty')">üî• 50/100</button>
                                <button class="tg-btn" onclick="sendMatchUpdate('${match.id}', 'innings')">üìä Innings Over</button>
                            </div>
                        </div>
                    </div>
                    <div class="admin-actions">
                        ${match.status === 'completed' ? `
                            <button class="btn-reset" onclick="resetMatchResult('${match.id}')">üîÑ Reset Result</button>
                        ` : ''}
                        <button class="btn-danger" onclick="deleteMatch('${match.id}')">üóëÔ∏è Delete</button>
                    </div>
                </div>
            `).join('');
        }

        // Render Matches (User View)
        async function renderMatches() {
            let matches = getLocalStorage('matches', []);
            const container = document.getElementById('matchesContainer');
            const noMatchesMsg = document.getElementById('noMatchesMsg');

            // Fetch matches from database for cross-device sync
            if (USE_DATABASE) {
                try {
                    const dbMatches = await dbCall('getMatches');
                    if (dbMatches && dbMatches.length > 0) {
                        matches = dbMatches.map(m => ({
                            id: m.id,
                            team1: { name: resolveTeamName(m.team1_name), flag: m.team1_flag, code: m.team1_code, group: m.team1_group },
                            team2: { name: resolveTeamName(m.team2_name), flag: m.team2_flag, code: m.team2_code, group: m.team2_group },
                            dateTime: m.date_time,
                            stage: m.stage,
                            status: m.status,
                            winner: m.winner,
                            points: m.points
                        }));
                        setLocalStorage('matches', matches);
                    }
                } catch (error) {
                    console.log('Failed to fetch matches from database, using localStorage:', error);
                }
            }

            const predictions = getLocalStorage('predictions', {});
            const userPredictions = predictions[currentUser?.username] || {};

            if (matches.length === 0) {
                container.innerHTML = '';
                noMatchesMsg.classList.remove('hidden');
                return;
            }

            noMatchesMsg.classList.add('hidden');

            container.innerHTML = matches.map(match => {
                const matchDate = new Date(match.dateTime);
                const now = new Date();
                const timeUntilMatch = matchDate - now;
                const isLocked = timeUntilMatch < (30 * 60 * 1000); // 30 minutes
                const isCompleted = match.status === 'completed';
                const userPrediction = userPredictions[match.id];
                const matchPoints = match.points || 1;

                // Calculate prediction statistics for this match
                const predictionStats = calculateMatchPredictionStats(match.id, predictions);

                return `
                    <div class="match-card">
                        <div class="match-header">
                            <div style="display: flex; align-items: center; gap: 0.5rem; flex-wrap: wrap;">
                                <span class="match-status-badge ${isCompleted ? 'badge-completed' : 'badge-upcoming'}">
                                    ${getStageLabel(match.stage || 'group')}
                                </span>
                                <span class="match-points-badge">‚≠ê${matchPoints}</span>
                                <span class="match-time">${formatDate(matchDate)}</span>
                            </div>
                        </div>

                        <div class="teams-container">
                            <div class="team ${userPrediction && userPrediction.team === match.team1.name ? 'selected' : ''} ${isLocked || isCompleted ? 'disabled' : ''}"
                                 onclick="${!isLocked && !isCompleted && !isAdmin ? `predictWinner('${match.id}', '${match.team1.name}')` : ''}">
                                <div class="team-flag">${getTeamFlag(match.team1.name)}</div>
                                <div class="team-name">${match.team1.name}</div>
                                <div class="team-code" style="font-size: 0.85rem; color: var(--text-gray);">
                                    ${getTeamGroup(match.team1.name)}
                                </div>
                            </div>

                            <div class="vs-divider">VS</div>

                            <div class="team ${userPrediction && userPrediction.team === match.team2.name ? 'selected' : ''} ${isLocked || isCompleted ? 'disabled' : ''}"
                                 onclick="${!isLocked && !isCompleted && !isAdmin ? `predictWinner('${match.id}', '${match.team2.name}')` : ''}">
                                <div class="team-flag">${getTeamFlag(match.team2.name)}</div>
                                <div class="team-name">${match.team2.name}</div>
                                <div class="team-code" style="font-size: 0.85rem; color: var(--text-gray);">
                                    ${getTeamGroup(match.team2.name)}
                                </div>
                            </div>
                        </div>

                        ${predictionStats.totalPredictions > 0 ? `
                            <div class="user-predictor-box">
                                <div class="user-predictor-title">üë• User Predictions</div>
                                <div class="user-predictor-stats">
                                    <div class="predictor-team">
                                        <span class="predictor-team-name">${match.team1.name}</span>
                                        <span class="predictor-team-percent">${predictionStats.team1Percent}%</span>
                                    </div>
                                    <div class="predictor-divider">|</div>
                                    <div class="predictor-team">
                                        <span class="predictor-team-name">${match.team2.name}</span>
                                        <span class="predictor-team-percent">${predictionStats.team2Percent}%</span>
                                    </div>
                                </div>
                            </div>
                        ` : ''}

                        ${!isCompleted && timeUntilMatch > 0 ? `
                            <div class="prediction-stat-box" style="${isLocked ? 'background: linear-gradient(135deg, #dc3545 0%, #c82333 100%);' : 'background: linear-gradient(135deg, var(--primary-blue) 0%, var(--secondary-blue) 100%);'} width: 100%; padding: 1rem; color: white; border-radius: 10px; text-align: center; margin: 1rem 0;">
                                <div class="prediction-stat-label">${isLocked ? 'üîí Locked' : '‚è∞ Time Left'}</div>
                                <div class="prediction-stat-value">${formatCountdown(timeUntilMatch)}</div>
                            </div>
                        ` : ''}

                        ${userPrediction && !isAdmin ? `
                            <div class="prediction-status prediction-${userPrediction.result}">
                                ${getPredictionStatusText(userPrediction, isCompleted, match.winner)}
                            </div>
                        ` : ''}

                        ${isCompleted && match.winner ? `
                            <div class="prediction-status" style="background: var(--light-blue); color: var(--primary-blue);">
                                <strong>Winner:</strong> ${match.winner}
                            </div>
                        ` : ''}
                    </div>
                `;
            }).join('');
        }

        // Prediction System
        async function predictWinner(matchId, teamName) {
            if (isAdmin) {
                showMessage('Admin cannot make predictions!', 'warning');
                return;
            }

            const matches = getLocalStorage('matches', []);
            const match = matches.find(m => m.id === matchId);

            if (!match) return;

            const matchDate = new Date(match.dateTime);
            const timeUntilMatch = matchDate - new Date();

            if (timeUntilMatch < (30 * 60 * 1000)) {
                showMessage('Predictions are locked! Must predict at least 30 minutes before match start.', 'error');
                return;
            }

            if (match.status === 'completed') {
                showMessage('Match has already completed!', 'error');
                return;
            }

            const predictions = getLocalStorage('predictions', {});
            if (!predictions[currentUser.username]) {
                predictions[currentUser.username] = {};
            }

            // Check if user is clicking the same team again (to remove prediction)
            const existingPrediction = predictions[currentUser.username][matchId];
            if (existingPrediction && existingPrediction.team === teamName) {
                // Remove the prediction
                delete predictions[currentUser.username][matchId];
                setLocalStorage('predictions', predictions);
                updateUserStats();
                renderMatches();

                // Sync deletion to database
                try {
                    await dbCall('deletePrediction', {
                        username: currentUser.username,
                        matchId: matchId
                    });
                } catch (e) {
                    console.log('Could not sync prediction deletion to database:', e.message);
                }

                showMessage('Prediction removed!', 'success');
                return;
            }

            // Save new prediction
            predictions[currentUser.username][matchId] = {
                team: teamName,
                timestamp: Date.now(),
                result: 'pending'
            };

            setLocalStorage('predictions', predictions);
            updateUserStats();
            renderMatches();

            // Sync prediction to database
            try {
                await dbCall('savePrediction', {
                    username: currentUser.username,
                    matchId: matchId,
                    team: teamName
                });
            } catch (e) {
                console.log('Could not sync prediction to database:', e.message);
            }

            showMessage(`Prediction saved! You picked ${teamName} to win.`, 'success');
        }

        // User Stats
        async function updateUserStats() {
            const predictions = getLocalStorage('predictions', {});
            const userPredictions = predictions[currentUser.username] || {};
            const matches = getLocalStorage('matches', []);

            let total = 0;
            let correct = 0;
            let points = 0;

            for (let matchId in userPredictions) {
                total++;
                if (userPredictions[matchId].result === 'correct') {
                    correct++;
                    // Get match points value (default to 1 if not set)
                    const match = matches.find(m => m.id === matchId);
                    const matchPoints = match?.points || 1;
                    points += matchPoints;
                }
            }

            const userStat = {
                username: currentUser.username,
                totalPredictions: total,
                correctPredictions: correct,
                points: points,
                accuracy: total > 0 ? ((correct / total) * 100).toFixed(1) : 0
            };

            const stats = getLocalStorage('userStats', {});
            stats[currentUser.username] = userStat;
            setLocalStorage('userStats', stats);

            // Sync stats to database
            try {
                await dbCall('updateStats', { stats: [userStat] });
            } catch (e) {
                console.log('Could not sync stats to database:', e.message);
            }
        }

        async function updateAllUserStats() {
            let predictions = getLocalStorage('predictions', {});
            const stats = getLocalStorage('userStats', {});
            let matches = getLocalStorage('matches', []);

            // Fetch ALL predictions from database to ensure completeness
            if (USE_DATABASE) {
                try {
                    const dbPredictions = await dbCall('getPredictions');
                    if (dbPredictions && dbPredictions.length > 0) {
                        for (const p of dbPredictions) {
                            if (!predictions[p.username]) {
                                predictions[p.username] = {};
                            }
                            // Only overwrite if DB has a result or local doesn't exist
                            if (!predictions[p.username][p.match_id] || p.result) {
                                predictions[p.username][p.match_id] = {
                                    team: p.team,
                                    result: p.result,
                                    timestamp: p.timestamp
                                };
                            }
                        }
                        setLocalStorage('predictions', predictions);
                    }
                } catch (e) {
                    console.log('Could not fetch predictions from database:', e.message);
                }
            }

            for (let username in predictions) {
                const userPredictions = predictions[username];
                let total = 0;
                let correct = 0;
                let points = 0;

                for (let matchId in userPredictions) {
                    total++;
                    if (userPredictions[matchId].result === 'correct') {
                        correct++;
                        // Get match points value (default to 1 if not set)
                        const match = matches.find(m => m.id === matchId);
                        const matchPoints = match?.points || 1;
                        points += matchPoints;
                    }
                }

                if (!stats[username]) {
                    stats[username] = { username: username };
                }

                stats[username].totalPredictions = total;
                stats[username].correctPredictions = correct;
                stats[username].points = points;
                stats[username].accuracy = total > 0 ? ((correct / total) * 100).toFixed(1) : 0;
            }

            setLocalStorage('userStats', stats);

            // Sync all stats to database
            try {
                const statsArray = Object.values(stats);
                if (statsArray.length > 0) {
                    await dbCall('updateStats', { stats: statsArray });
                }
            } catch (e) {
                console.log('Could not sync stats to database:', e.message);
            }
        }

        // Leaderboard
        function updateLeaderboard() {
            const stats = getLocalStorage('userStats', {});
            const leaderboardData = Object.values(stats)
                .filter(user => user.username !== 'admin') // Exclude admin
                .sort((a, b) => b.points - a.points || b.correctPredictions - a.correctPredictions);

            const tbody = document.getElementById('leaderboardBody');
            const actionsHeader = document.getElementById('leaderboardActionsHeader');

            // Show/hide Actions column header based on admin status
            if (isAdmin) {
                actionsHeader.classList.remove('hidden');
            } else {
                actionsHeader.classList.add('hidden');
            }

            if (leaderboardData.length === 0) {
                const colspan = isAdmin ? '5' : '4';
                tbody.innerHTML = `<tr><td colspan="${colspan}" style="text-align: center; padding: 2rem;">No predictions yet. Start predicting!</td></tr>`;
                return;
            }

            tbody.innerHTML = leaderboardData.map((user, index) => {
                const rank = index + 1;
                const isCurrentUser = user.username === currentUser?.username;

                let rankBadgeClass = '';
                if (rank === 1) rankBadgeClass = 'gold';
                else if (rank === 2) rankBadgeClass = 'silver';
                else if (rank === 3) rankBadgeClass = 'bronze';

                return `
                    <tr class="${isCurrentUser ? 'current-user-row' : ''}">
                        <td><span class="rank-badge ${rankBadgeClass}">${rank}</span></td>
                        <td><strong>${user.username}</strong> ${isCurrentUser ? '(You)' : ''}</td>
                        <td><strong style="color: var(--success-green); font-size: 1.3rem;">${user.points}</strong></td>
                        <td>${user.accuracy}%</td>
                        ${isAdmin ? `
                            <td>
                                <button class="btn-delete-user" onclick="deleteUserFromLeaderboard('${user.username}')" style="font-size: 0.9rem; padding: 0.4rem 0.8rem;">
                                    üóëÔ∏è Remove
                                </button>
                            </td>
                        ` : ''}
                    </tr>
                `;
            }).join('');
        }

        // Delete user from leaderboard (admin only)
        function deleteUserFromLeaderboard(username) {
            if (!isAdmin) {
                alert('Only admins can delete users!');
                return;
            }

            // Call the existing deleteUser function
            deleteUser(username);
        }

        // Helper Functions
        function formatDate(date) {
            return date.toLocaleDateString('en-US', {
                month: 'short',
                day: 'numeric',
                hour: '2-digit',
                minute: '2-digit'
            });
        }

        function formatDateTime(dateTimeString) {
            const date = new Date(dateTimeString);
            return date.toLocaleString('en-US', {
                month: 'short',
                day: 'numeric',
                year: 'numeric',
                hour: '2-digit',
                minute: '2-digit'
            });
        }

        function formatCountdown(ms) {
            if (ms < 0) return 'Match Started';

            const hours = Math.floor(ms / (1000 * 60 * 60));
            const minutes = Math.floor((ms % (1000 * 60 * 60)) / (1000 * 60));

            if (hours > 24) {
                const days = Math.floor(hours / 24);
                return `${days}d ${hours % 24}h`;
            }

            return `${hours}h ${minutes}m`;
        }

        function calculateMatchPredictionStats(matchId, allPredictions) {
            let team1Count = 0;
            let team2Count = 0;
            let totalPredictions = 0;

            // Get the match to know team names
            const matches = getLocalStorage('matches', []);
            const match = matches.find(m => m.id === matchId);
            if (!match) return { team1Count: 0, team2Count: 0, totalPredictions: 0, team1Percent: 0, team2Percent: 0 };

            // Count predictions for each team
            Object.values(allPredictions).forEach(userPredictions => {
                const prediction = userPredictions[matchId];
                if (prediction) {
                    totalPredictions++;
                    if (prediction.team === match.team1.name) {
                        team1Count++;
                    } else if (prediction.team === match.team2.name) {
                        team2Count++;
                    }
                }
            });

            // Calculate percentages
            const team1Percent = totalPredictions > 0 ? Math.round((team1Count / totalPredictions) * 100) : 0;
            const team2Percent = totalPredictions > 0 ? Math.round((team2Count / totalPredictions) * 100) : 0;

            return {
                team1Count,
                team2Count,
                totalPredictions,
                team1Percent,
                team2Percent
            };
        }

        function getPredictionStatusText(prediction, matchEnded, winner) {
            if (prediction.result === 'correct') {
                return `‚úÖ Correct! You predicted ${prediction.team} (+1 point)`;
            } else if (prediction.result === 'incorrect') {
                return `‚ùå Incorrect. You predicted ${prediction.team}, winner was ${winner}`;
            } else {
                return `‚è≥ You predicted: ${prediction.team}`;
            }
        }

        function showMessage(message, type = 'info') {
            const container = document.getElementById('messageContainer');
            const className = type === 'success' ? 'success-message' :
                             type === 'error' ? 'error-message' : 'warning-message';

            container.innerHTML = `<div class="${className}">${message}</div>`;
            setTimeout(() => container.innerHTML = '', 5000);
        }

        function showError(message, elementId) {
            const element = document.getElementById(elementId);
            element.textContent = message;
            element.classList.remove('hidden');
            setTimeout(() => element.classList.add('hidden'), 5000);
        }

        function getStageLabel(stage) {
            const stageLabels = {
                'group': '‚ö° Group Stage',
                'super8': 'üî• Super 8',
                'semi': 'ü•à Semi Final',
                'final': 'üèÜ Final'
            };
            return stageLabels[stage] || '‚ö° Group Stage';
        }

        function getTeamGroup(teamName) {
            const team = TEAMS.find(t => t.name === teamName);
            return team ? `Group ${team.group}` : '';
        }

        // Check for existing session on page load
        window.addEventListener('DOMContentLoaded', () => {
            // Initialize users database with admin
            initializeUsers();

            // Load group stage fixtures on first run
            loadGroupStageFixtures();

            const savedUser = getLocalStorage('currentUser');
            const savedIsAdmin = getLocalStorage('isAdmin', false);

            if (savedUser) {
                currentUser = savedUser;
                isAdmin = savedIsAdmin;
                initializeApp();
            }
        });

        // ============================================
        // DATA BACKUP & RESTORE FUNCTIONS
        // ============================================

        async function syncToDatabase() {
            if (!confirm('Sync all localStorage data to database? This will upload all users, predictions, matches, and stats.')) {
                return;
            }

            try {
                showMessage('Syncing to database...', 'success');

                // Sync users
                const users = getLocalStorage('users', []);
                for (const user of users) {
                    try {
                        await dbCall('addUser', {
                            username: user.username,
                            phone: user.phone,
                            password: user.password,
                            role: user.role,
                            needsReset: user.needsPasswordChange || false
                        });
                    } catch (e) {
                        console.log(`User ${user.username} already exists or error:`, e.message);
                    }
                }

                // Sync matches
                const matches = getLocalStorage('matches', []);
                for (const match of matches) {
                    try {
                        await dbCall('addMatch', { match });
                    } catch (e) {
                        console.log(`Match ${match.id} already exists or error:`, e.message);
                    }
                }

                // Sync predictions
                const predictions = getLocalStorage('predictions', {});
                for (const username in predictions) {
                    const userPreds = predictions[username];
                    for (const matchId in userPreds) {
                        const pred = userPreds[matchId];
                        try {
                            await dbCall('savePrediction', {
                                username,
                                matchId,
                                team: pred.team,
                                result: pred.result || null
                            });
                        } catch (e) {
                            console.log(`Prediction error:`, e.message);
                        }
                    }
                }

                // Sync stats
                const stats = getLocalStorage('userStats', {});
                const statsArray = Object.values(stats);
                if (statsArray.length > 0) {
                    await dbCall('updateStats', { stats: statsArray });
                }

                showMessage('‚úÖ Successfully synced all data to database!', 'success');
            } catch (error) {
                showMessage('Sync failed: ' + error.message, 'error');
            }
        }

        function exportAllData() {
            const allData = {
                users: getLocalStorage('users', []),
                predictions: getLocalStorage('predictions', {}),
                userStats: getLocalStorage('userStats', {}),
                matches: getLocalStorage('matches', []),
                exportDate: new Date().toISOString(),
                appVersion: '1.0'
            };

            const dataStr = JSON.stringify(allData, null, 2);
            const dataBlob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(dataBlob);
            const link = document.createElement('a');
            link.href = url;
            link.download = `t20-worldcup-backup-${new Date().toISOString().split('T')[0]}.json`;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(url);

            alert('‚úÖ Backup downloaded successfully!\n\nSave this file in a safe place (Google Drive, Dropbox, etc.)');
        }

        function importAllData(event) {
            const file = event.target.files[0];
            if (!file) return;

            if (!confirm('‚ö†Ô∏è WARNING: This will REPLACE all current data with the backup file.\n\nMake sure you have a current backup before proceeding.\n\nContinue?')) {
                event.target.value = '';
                return;
            }

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const data = JSON.parse(e.target.result);

                    // Validate data structure
                    if (!data.users || !Array.isArray(data.users)) {
                        throw new Error('Invalid backup file: Missing users data');
                    }

                    // Restore all data
                    setLocalStorage('users', data.users);
                    setLocalStorage('predictions', data.predictions || {});
                    setLocalStorage('userStats', data.userStats || {});
                    setLocalStorage('matches', data.matches || []);

                    alert(`‚úÖ Data restored successfully!\n\nRestored:\n- ${data.users.length} users\n- ${Object.keys(data.predictions || {}).length} prediction sets\n- ${data.matches?.length || 0} matches\n\nPage will refresh...`);

                    location.reload();
                } catch (error) {
                    alert(`‚ùå Error restoring backup:\n${error.message}\n\nPlease check the backup file and try again.`);
                }
            };
            reader.readAsText(file);
            event.target.value = '';
        }

        function updateDataStats() {
            const users = getLocalStorage('users', []);
            const predictions = getLocalStorage('predictions', {});
            const matches = getLocalStorage('matches', []);
            const userStats = getLocalStorage('userStats', {});

            const statsContainer = document.getElementById('dataStats');
            if (statsContainer) {
                statsContainer.innerHTML = `
                    üë• Users: <strong>${users.length}</strong><br>
                    üéØ Total Predictions: <strong>${Object.keys(predictions).length}</strong><br>
                    ‚öΩ Matches: <strong>${matches.length}</strong><br>
                    üìä User Stats: <strong>${Object.keys(userStats).length}</strong><br>
                    üìÖ Last Update: <strong>${new Date().toLocaleString()}</strong>
                `;
            }
        }

        // Check for duplicate phone numbers
        async function checkDuplicatePhones() {
            const panel = document.getElementById('duplicatePhonePanel');
            const list = document.getElementById('duplicatePhonesList');

            if (!USE_DATABASE) {
                alert('Database mode is not enabled.');
                return;
            }

            try {
                const duplicates = await dbCall('getDuplicatePhones');

                if (duplicates.length === 0) {
                    panel.style.display = 'none';
                    alert('‚úÖ No duplicate phone numbers found!');
                    return;
                }

                panel.style.display = 'block';
                list.innerHTML = duplicates.map(dup => `
                    <div style="background: white; padding: 1rem; border-radius: 8px; margin-bottom: 0.5rem;">
                        <strong>üì± +960 ${dup.phone}</strong> - Used by ${dup.count} users:<br>
                        <span style="color: #721c24;">${dup.usernames.join(', ')}</span>
                    </div>
                `).join('');

            } catch (error) {
                alert('Error checking duplicates: ' + error.message);
            }
        }

        // Update stats when users tab is shown
        const originalShowTab = window.showTab;
        window.showTab = function(tabName) {
            if (originalShowTab) originalShowTab(tabName);
            if (tabName === 'users') {
                updateDataStats();
            }
        };
    </script>
</body>
</html>
